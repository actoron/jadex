// Separated versioning utilities, used by main build.gradle as well as docs/mkdocs-ng
Object fetchNextBuildNameFromGitTag()
{
	// Fetch major.minor version from properties
	//def versionprops = readProperties file: 'src/main/buildutils/jadexversion.properties'
	def versionprops = new Properties()
	//file("src/main/buildutils/jadexversion.properties").withInputStream { versionprops.load(it) }
	file("${workspaceRootDir}/src/main/buildutils/jadexversion.properties").withInputStream { versionprops.load(it) }

	def version = versionprops.jadexversion_major + "." + versionprops.jadexversion_minor
	//println "version from props is: "+version+ ", " + versionprops
	
	// If we are rebuilding from unzipped distribution sources, get patch from properties.
	if(versionprops.containsKey("jadexversion_patch") && versionprops.jadexversion_patch.isInteger())
		return createBuildname(version, versionprops.jadexversion_patch, 1, false)

	// If we are building in dev mode (i.e. Eclipse), just set patch to 9999 and exit.
	if (!gradle.ext.productionmode)
		return createBuildname(version, 9999, 1, false)
		
	def patch = getLatestPatchVersion(version, versionprops);
	
	//println "patch from git is: "+patch
	
	def branchpatch = 1; // Start branch subnumbers at 1, because jadex-1.2.3-branch-0 is ugly(?)
	def buildname	= null;

	// Fetch latest major.minor.patch[-branchname-branchpatch] tag from git for non-master/stable branches
	
	// todo
	/*if(includeBranchName(env.BRANCH_NAME)) {
		def suffix = getLatestTagSuffix(version+"."+patch+"-"+env.BRANCH_NAME+"-")
		if(suffix!=null)
			branchpatch = suffix as Integer;
	}*/
	
	// Create the build name based on version path and branch info.		
	buildname = createBuildname(version, patch, branchpatch, false)
	
	// If tag for buildname exists, but is not head -> there are commits since last tag -> increment (branch) patch number.
	if(getLatestTagSuffix(buildname.full)!=null && !isHead(buildname.full))
	{
		//if(includeBranchName(env.BRANCH_NAME))
		//	branchpatch++
		//else
			patch++
		buildname = createBuildname(version, patch, branchpatch, true)
	}
	
	return buildname!=null ? buildname : createBuildname(version, patch, branchpatch, false);
}

/**
 *  Check if a branch name should be included in version number.
 */
boolean includeBranchName(branch)
{
	return !"master".equals(branch) && !"stable".equals(branch);
}

/**
 *  Create the build name object.
 */
Object	createBuildname(version, patch, branchpatch, isnew)
{
	def buildname = new HashMap() {
		public String toString()
		{
			return "" + this.major + "." + this.minor + "." + this.patch;
		}
	};
	
	//def buildname = [:]
	//buildname.suffix = patch + (includeBranchName(env.BRANCH_NAME) ? "-"+env.BRANCH_NAME+"-"+branchpatch : "")
	def splitversion = version.split("\\.");
	buildname.major = Integer.valueOf(splitversion[0]);
	buildname.minor = Integer.valueOf(splitversion[1]);
	buildname.patch = patch;
	buildname.suffix = patch;
	buildname.full = version + "." +buildname.suffix
	buildname.isnew	= isnew;	// isnew -> no tag for this version exists, yet
	return buildname;
}

/**
 *  Fetch all tags matching the given major.minor version and 
 *  return the latest patch version.
 *  @return The found patch version or 0 if not found.
 */
int getLatestPatchVersion(version, versionprops)
{
	def	patch = 0
	//def status = sh (returnStatus: true,
	//	script: "git log --tags=\"${version}.*\" --no-walk --format=%D >tags.txt")
	
	def git = "git log --tags=${version}.* --no-walk --format=%D";
	//println "git command: "+git
	
	def p1 = git.execute()
	p1.waitFor()
	//println p1.errorStream.text
	
	def status = p1.exitValue()
	def tags = p1.text.split("\\n")
	
	//println "tags are: "+ tags 
	
	if(status==0)
	{
		for(String tag: tags)
		{
			if(tag.startsWith("tag: "+version+"."))
			{
				tag	= tag.substring(("tag: "+version+".").length())
				if(tag.indexOf("-")!=-1)	// Strip version branch names in tag
					tag	= tag.substring(0, tag.indexOf("-"));
				if(tag.indexOf(",")!=-1)	// Strip git branch names after tag
					tag	= tag.substring(0, tag.indexOf(","));
				
				if(tag.matches("\\d+"))	// Skip tags not conforming to <major>.<minor>.<patch> or <major>.<minor>.<patch>-<branch>-<branchpatch>
				{
				 	patch = Math.max(patch, tag as Integer)
				}
				else
				{
					println "ignored "+tag
				}
			}
		}
	}
	return patch
}

/**
 *  Fetch the latest tag matching the given prefix and return the suffix.
 *  @return The suffix or null, when no matching tag is found.
 */
String getLatestTagSuffix(prefix)
{
	//def status = sh (returnStatus: true,
	//	script: "git describe --match \"${prefix}*\" --abbrev=0 > tag.txt")
	//git log --tags="4.0.*" --no-walk --format=%D >tags.txt
	
	//if (project.ext.productionmode)
	//{
		def cmd = "git describe --match ${prefix} --abbrev=0";
		def p1 = cmd.execute();
		p1.waitFor()
		
		def status = p1.exitValue()
		return status==0? p1.text.trim().substring(prefix.length()): null;
	//}
	
}

/**
 *  Check if a tag points to HEAD.
 */
boolean	isHead(tag)
{
	println "Checking if "+ tag +" points to HEAD"
	//def status = sh (returnStatus: true,
	//	script: "git tag --points-at HEAD > tags.txt")
	
	def p1 = "git tag --points-at HEAD.execute()".execute()
	p1.waitFor()
	
	def status = p1.exitValue()
	def tags = p1.text
		
	if(status==0)
		return java.util.Arrays.asList(tags.trim().split("\\n")).contains(tag)
	return false;
}

ext {
	fetchNextBuildNameFromGitTag = this.&fetchNextBuildNameFromGitTag
}