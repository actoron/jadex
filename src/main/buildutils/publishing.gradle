//apply plugin: 'maven-publish'

apply plugin: 'signing'

apply plugin: 'de.marcphilipp.nexus-publish'

project.rootProject.plugins.apply('io.codearte.nexus-staging') // auto-close nexus-oss staging

def common() {
	return {
        scm {
            url 'http://jadex.svn.sourceforge.net/viewvc/jadex/'
        }

        url 'https://www.activecomponents.org'

        // beware: organization needs '=' assignment:
        // https://issues.gradle.org/browse/GRADLE-2719
        developers {
            developer {
                id 'alex'
                name 'Alexander Pokahr'
                email 'pokahr@gmx.net'
                //                url 'http://vsis-www.informatik.uni-hamburg.de/members/info.php/84'
                //                organization 'University of Hamburg'
                //                organizationUrl 'http://vsis-www.informatik.uni-hamburg.de/'
                organization 'Actoron GmbH'
                organizationUrl 'https://actoron.com/'
            }
            developer {
                id 'lars'
                name 'Lars Braubach'
                email 'braubach@gmx.net'
                //                url 'http://vsis-www.informatik.uni-hamburg.de/members/info.php/80'
                //                organization 'University of Hamburg'
                //                organizationUrl 'http://vsis-www.informatik.uni-hamburg.de/'
                organization 'Actoron GmbH'
                organizationUrl 'https://actoron.com/'
            }
            developer {
                id 'kai'
                name 'Kai Jander'
                email 'kai.jander@googlemail.com'
                //                url 'http://vsis-www.informatik.uni-hamburg.de/members/info.php/974'
                //                organization 'University of Hamburg'
                //                organizationUrl 'http://vsis-www.informatik.uni-hamburg.de/'
                organization 'Actoron GmbH'
                organizationUrl 'https://actoron.com/'
            }
            developer {
                id 'julian'
                name 'Julian Kalinowski'
                email 'kalinowski@informatik.uni-hamburg.de'
                //                url 'http://vsis-www.informatik.uni-hamburg.de/members/info.php/974'
                //                organization 'Actoron GmbH'
                //                organizationUrl 'https://actoron.com/'
                organization 'University of Hamburg'
                organizationUrl 'http://vsis-www.informatik.uni-hamburg.de/'
            }
        }

    }
}

def commercial() {
	return {
        licenses {
            license {
                name 'Actoron GmbH Commercial Licence'
            }
        }
    }
}

def gpl() {
	return {
		licenses {
			license {
				name 'GPL-3.0'
				url 'https://gnu.org/licenses/gpl-3.0'
				distribution 'repo'
			}
		}
	}
}


// -------------------------------------
// ------------ PUBLISH ----------------
// -------------------------------------

//def canPublishToNexus = isCommercial(project) && repo_commercial || !isCommercial(project) && repo_noncommercial
def canSign = project.hasProperty('signing.secretKeyRingFile') || getVar("signingKey", project)!=null

//println getVar("signingKey", project)

//// Selects the projects to publish, add a better heuristic here if available
//def includedproject = getProjectDepth(project) > 1
//// Empty project
//includedproject &= !project.path.equals(':android:applications')

def configurePom(pom) {
    pom.withXml {
        def root = asNode()
        root.appendNode('description', project.description)
        root.appendNode('name', project.name)
        if (isAndroidProject(project)) 
        {
            root.get('packaging').get(0).setValue('aar')
            def dependenciesNode = asNode().appendNode('dependencies')
            project.configurations.implementation.allDependencies.each 
            {
                // Ensure dependencies such as fileTree are not included.
                if (it.name != 'unspecified') 
                {
                    def dependencyNode = dependenciesNode.appendNode('dependency')
                    dependencyNode.appendNode('groupId', it.group)
                    dependencyNode.appendNode('artifactId', it.name)
                    dependencyNode.appendNode('version', it.version)
                }
            }
        } 
        else if (!root.get('packaging').isEmpty()) 
        {
            root.remove(root.get('packaging'))
        }
        root.children().last() + common()
        root.children().last() + gpl()

//        // workaround for compile-time scope in POMs: (remove with gradle 4.7 or something)
//        asNode().dependencies.'*'.findAll() {
//        it.scope.text() == 'runtime' && project.configurations.compile.allDependencies.find { dep ->
//            dep.name == it.artifactId.text()
//        }
//        }.each { it.scope*.value = 'compile' }
    }
}

if(project.hasProperty('repo')) {

	if("central".equalsIgnoreCase(repo)) {
/*		project.rootProject.afterEvaluate {
		    nexusStaging {
		        packageGroup = "org.activecomponents" //optional if packageGroup == project.getGroup()
		        stagingProfileId = "5bcba2b9075ec8" //when not defined will be got from server using "packageGroup"
		        username = getVar('repocentraluser', project)
		        password = getVar('repocentralpassword', project)
		    }
		}
*/		
		nexusPublishing {
			repositories {
		    	sonatype() {
		        	connectTimeout = Duration.ofMinutes(10)
		        	clientTimeout = Duration.ofMinutes(10)
			        username = getVar('repocentraluser', project)
			        password = getVar('repocentralpassword', project)
		        }
		    }
		}
		
		// Hack!!! initializeSonatypeStagingRepository messes up when run in parallel, so let :util:commons do the work and others wait 
		if(!':util:commons'.equals(project.path)) {
			project.rootProject.afterEvaluate {
			    tasks.getByName("initializeSonatypeStagingRepository").dependsOn project.rootProject.ext.subprojectmap.get(':util:commons').tasks.getByName("initializeSonatypeStagingRepository")
			}
		}
	}

	else {
		publishing {
	        repositories
	        {
	            def myrepourl = getVar('repo'+repo+'url', project)
	            def myrepouser = getVar('repo'+repo+'user', project)
	            def myrepopassword = getVar('repo'+repo+'password', project);
	            
	//            println "publishing to: "+myrepourl
	//            println "repouser: "+myrepouser
	//            println "repopassword: "+myrepopassword
	            
	            maven {
	                url myrepourl
	                credentials {
	                    username myrepouser
	                    password myrepopassword
	                }
	            }
	        }
	    }
    }

	publishing {	
	    publications {
	        if(canSign && (!isAndroidProject(project) || isAndroidLibraryProject(project)))  // dont publish apks
	        { 
	        	// publish plugin requires each subproject having mavenJava
	        
	        	mavenJava(MavenPublication)
	        	{
/*		        	if(gradle.ext.webprojects.contains(project.getPath()))
		            {
	        			from components.web
	        		}
	        		else
	        		{
	        			from components.java
*/	        			
	        			project.tasks.withType(Jar) 
	                    {
	                        //if(it.name.endsWith('jar') && !it.name.contains('sources') && !it.name.contains('javadoc')) 
	                        //{
	                            artifact(it)
	                        //}
	                    }
//	        		}
	        		
	        		//groupId group
					groupId isCommercial(project) ? 'com.actoron.jadex' : 'org.activecomponents.jadex'
					//artifactId project.name
					artifactId getArtifactName(project)
					//println 'ARTIDD!!! ' + artifactId + ' ' + project.getPath()
					version project.version
					configurePom(pom)
	        	}
			}
		}
	}     
}


if(canSign) {
	signing {
		// for signing with keys by environment variables https://docs.gradle.org/current/userguide/signing_plugin.html
		//def signingKey1 = findProperty("signingKey")
		//def signingPassword1 = findProperty("signingPassword")
		//println("sign key1: "+signingKey1)
		
		
		def signingKey = getVar("signingKey", project)
		def signingPassword = getVar("signingPassword", project)
		//println("sign key2: "+signingKey)
		useInMemoryPgpKeys(signingKey, signingPassword)
	
//		sign configurations.archives
		if (isAndroidProject(project)) { // add manually because somehow, those tasks do not end up in configurations.archives??
			sign project.tasks.androidsourcesJar
			sign project.tasks.androidjavadocsJar
		}
		if (!isAndroidProject(project) || isAndroidLibraryProject(project)) { // dont publish apks
			//sign publishing.publications.ProjectPublication
			sign publishing.publications.mavenJava
		}
	}
	
	
}


