<?xml version="1.0" encoding="UTF-8"?>
<xs:schema targetNamespace="http://www.activecomponents.org/jadex-bdi" xmlns="http://www.activecomponents.org/jadex-bdi" xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" attributeFormDefault="unqualified">
	<xs:include schemaLocation="http://www.activecomponents.org/jadex-component-base-${jadex_build_version}.xsd"/>
	
	<xs:element name="agent" type="agenttype">
		<xs:annotation>
			<xs:documentation>Defines a new agent type.</xs:documentation>
		</xs:annotation>
		<xs:key name="agent_capability_name">
			<xs:selector xpath="capabilities/capability"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:key name="agent_belief_name">
			<xs:selector xpath="beliefs/belief|beliefs/beliefset|beliefs/beliefref|beliefs/beliefsetref"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:key name="agent_belief_key">
			<xs:selector xpath="beliefs/belief|beliefs/beliefref"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:key name="agent_beliefset_key">
			<xs:selector xpath="beliefs/beliefset|beliefs/beliefsetref"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:key name="agent_goal_name">
			<xs:selector xpath="goals/performgoal|goals/achievegoal|goals/querygoal|goals/maintaingoal|goals/metagoal|goals/performgoalref|goals/achievegoalref|goals/querygoalref|goals/maintaingoalref|goals/metagoalref"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:key name="agent_plan_name">
			<xs:selector xpath="plans/plan"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:key name="agent_internalevent_name">
			<xs:selector xpath="events/internalevent|events/internaleventref"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:key name="agent_messageevent_name">
			<xs:selector xpath="events/messageevent|events/messageeventref"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:keyref name="agent_belief_trigger" refer="agent_belief_name">
			<xs:selector xpath="plans/plan/trigger/factchanged"/>
			<xs:field xpath="@ref"/>
			<!-- Both beliefs and belief sets allowed. -->
		</xs:keyref>
		<xs:keyref name="agent_beliefset_trigger" refer="agent_beliefset_key">
			<xs:selector xpath="plans/plan/trigger/factadded|plans/plan/trigger/factremoved"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:keyref name="agent_goal_trigger" refer="agent_goal_name">
			<xs:selector xpath="plans/plan/trigger/goalfinished|plans/plan/trigger/goal|plans/plan/waitqueue/goalfinished|goals/metagoal/trigger/goalfinished|goals/metagoal/trigger/goal"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:keyref name="agent_internalevent_trigger" refer="agent_internalevent_name">
			<xs:selector xpath="plans/plan/trigger/internalevent|plans/plan/waitqueue/internalevent|goals/metagoal/trigger/internalevent"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:keyref name="agent_messageevent_trigger" refer="agent_messageevent_name">
			<xs:selector xpath="plans/plan/trigger/messageevent|plans/plan/waitqueue/messageevent|goals/metagoal/trigger/messageevent"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:keyref name="agent_inhibits_reference" refer="agent_goal_name">
			<xs:selector xpath="goals/performgoal/deliberation/inhibits|goals/achievegoal/deliberation/inhibits|goals/querygoal/deliberation/inhibits|goals/maintaingoal/deliberation/inhibits|goals/metagoal/deliberation/inhibits|goals/performgoalref/deliberation/inhibits|goals/achievegoalref/deliberation/inhibits|goals/querygoalref/deliberation/inhibits|goals/maintaingoalref/deliberation/inhibits|goals/metagoalref/deliberation/inhibits"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:keyref name="agent_capability_reference" refer="agent_capability_name">
			<xs:selector xpath="configurations/configuration/capabilities/initialcapability"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:keyref name="agent_belief_reference" refer="agent_belief_key">
			<xs:selector xpath="configurations/configuration/beliefs/initialbelief"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:keyref name="agent_beliefset_reference" refer="agent_beliefset_key">
			<xs:selector xpath="configurations/configuration/beliefs/initialbeliefset"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:keyref name="agent_goal_reference" refer="agent_goal_name">
			<xs:selector xpath="configurations/configuration/goals/initialgoal|configurations/configuration/goals/endgoal"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:keyref name="agent_plan_reference" refer="agent_plan_name">
			<xs:selector xpath="configurations/configuration/plans/initialplan|configurations/configuration/plans/endplan"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:keyref name="agent_internalevent_reference" refer="agent_internalevent_name">
			<xs:selector xpath="configurations/configuration/internalevents/initialinternalevent|configurations/configuration/internalevents/endinternalevent"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:keyref name="agent_messageevent_reference" refer="agent_messageevent_name">
			<xs:selector xpath="configurations/configuration/messageevents/initialmessageevent|configurations/configuration/messageevents/endmessageevent"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:key name="agent_component_name">
			<xs:selector xpath="componenttypes/componenttype"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:key name="agent_providedservice_key">
			<xs:selector xpath="services/providedservice"/>
			<xs:field xpath="@name|@class"/>
		</xs:key>
		<xs:unique name="agent_providedservice_name">
			<xs:selector xpath="services/providedservice"/>
			<xs:field xpath="@name"/>
		</xs:unique>
		<xs:key name="agent_requiredservice_name">
			<xs:selector xpath="services/requiredservice"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:key name="agent_property_name">
			<xs:selector xpath="properties/property"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:keyref name="agent_component_reference" refer="agent_component_name">
			<xs:selector xpath="configurations/configuration/components/component"/>
			<xs:field xpath="@type"/>
		</xs:keyref>
		<xs:keyref name="agent_providedservice_reference" refer="agent_providedservice_key">
			<xs:selector xpath="configurations/configuration/services/providedservice"/>
			<xs:field xpath="@name|@class"/>
		</xs:keyref>
		<xs:keyref name="agent_requiredservice_reference" refer="agent_requiredservice_name">
			<xs:selector xpath="configurations/configuration/services/requiredservice"/>
			<xs:field xpath="@name"/>
		</xs:keyref>
		<!-- unique keys on type level -->
		<!-- key references in triggers / deliberation -->
		<!-- key references in configurations -->
		<!-- copied from jadex-component.xsd, prefixed with 'agent_' to avoid name clashes. -->
	</xs:element>
	<xs:element name="capability" type="MCapability">
		<xs:annotation>
			<xs:documentation>Defines a new capability type.</xs:documentation>
		</xs:annotation>
		<xs:key name="capa_capability_name">
			<xs:selector xpath="capabilities/capability"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:key name="capa_belief_name">
			<xs:selector xpath="beliefs/belief|beliefs/beliefset|beliefs/beliefref|beliefs/beliefsetref"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:key name="capa_belief_key">
			<xs:selector xpath="beliefs/belief|beliefs/beliefref"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:key name="capa_beliefset_key">
			<xs:selector xpath="beliefs/beliefset|beliefs/beliefsetref"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:key name="capa_goal_name">
			<xs:selector xpath="goals/performgoal|goals/achievegoal|goals/querygoal|goals/maintaingoal|goals/metagoal|goals/performgoalref|goals/achievegoalref|goals/querygoalref|goals/maintaingoalref|goals/metagoalref"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:key name="capa_plan_name">
			<xs:selector xpath="plans/plan"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:key name="capa_internalevent_name">
			<xs:selector xpath="events/internalevent|events/internaleventref"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:key name="capa_messageevent_name">
			<xs:selector xpath="events/messageevent|events/messageeventref"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:keyref name="capa_belief_trigger" refer="capa_belief_name">
			<xs:selector xpath="plans/plan/trigger/factchanged"/>
			<xs:field xpath="@ref"/>
			<!-- Both beliefs and belief sets allowed. -->
		</xs:keyref>
		<xs:keyref name="capa_beliefset_trigger" refer="capa_beliefset_key">
			<xs:selector xpath="plans/plan/trigger/factadded|plans/plan/trigger/factremoved"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:keyref name="capa_goal_trigger" refer="capa_goal_name">
			<xs:selector xpath="plans/plan/trigger/goalfinished|plans/plan/trigger/goal|plans/plan/waitqueue/goalfinished|goals/metagoal/trigger/goalfinished|goals/metagoal/trigger/goal"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:keyref name="capa_internalevent_trigger" refer="capa_internalevent_name">
			<xs:selector xpath="plans/plan/trigger/internalevent|plans/plan/waitqueue/internalevent|goals/metagoal/trigger/internalevent"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:keyref name="capa_messageevent_trigger" refer="capa_messageevent_name">
			<xs:selector xpath="plans/plan/trigger/messageevent|plans/plan/waitqueue/messageevent|goals/metagoal/trigger/messageevent"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:keyref name="capa_inhibits_reference" refer="capa_goal_name">
			<xs:selector xpath="goals/performgoal/deliberation/inhibits|goals/achievegoal/deliberation/inhibits|goals/querygoal/deliberation/inhibits|goals/maintaingoal/deliberation/inhibits|goals/metagoal/deliberation/inhibits|goals/performgoalref/deliberation/inhibits|goals/achievegoalref/deliberation/inhibits|goals/querygoalref/deliberation/inhibits|goals/maintaingoalref/deliberation/inhibits|goals/metagoalref/deliberation/inhibits"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:keyref name="capa_capability_reference" refer="capa_capability_name">
			<xs:selector xpath="configurations/configuration/capabilities/initialcapability"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:keyref name="capa_belief_reference" refer="capa_belief_key">
			<xs:selector xpath="configurations/configuration/beliefs/initialbelief"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:keyref name="capa_beliefset_reference" refer="capa_beliefset_key">
			<xs:selector xpath="configurations/configuration/beliefs/initialbeliefset"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:keyref name="capa_goal_reference" refer="capa_goal_name">
			<xs:selector xpath="configurations/configuration/goals/initialgoal|configurations/configuration/goals/endgoal"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:keyref name="capa_plan_reference" refer="capa_plan_name">
			<xs:selector xpath="configurations/configuration/plans/initialplan|configurations/configuration/plans/endplan"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:keyref name="capa_internalevent_reference" refer="capa_internalevent_name">
			<xs:selector xpath="configurations/configuration/internalevents/initialinternalevent|configurations/configuration/internalevents/endinternalevent"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:keyref name="capa_messageevent_reference" refer="capa_messageevent_name">
			<xs:selector xpath="configurations/configuration/messageevents/initialmessageevent|configurations/configuration/messageevents/endmessageevent"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
		<xs:key name="capa_component_name">
			<xs:selector xpath="componenttypes/componenttype"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:key name="capa_providedservice_key">
			<xs:selector xpath="services/providedservice"/>
			<xs:field xpath="@name|@class"/>
		</xs:key>
		<xs:unique name="capa_providedservice_name">
			<xs:selector xpath="services/providedservice"/>
			<xs:field xpath="@name"/>
		</xs:unique>
		<xs:key name="capa_requiredservice_name">
			<xs:selector xpath="services/requiredservice"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:key name="capa_property_name">
			<xs:selector xpath="properties/property"/>
			<xs:field xpath="@name"/>
		</xs:key>
		<xs:keyref name="capa_component_reference" refer="capa_component_name">
			<xs:selector xpath="configurations/configuration/components/component"/>
			<xs:field xpath="@type"/>
		</xs:keyref>
		<xs:keyref name="capa_providedservice_reference" refer="capa_providedservice_key">
			<xs:selector xpath="configurations/configuration/services/providedservice"/>
			<xs:field xpath="@name|@class"/>
		</xs:keyref>
		<xs:keyref name="capa_requiredservice_reference" refer="capa_requiredservice_name">
			<xs:selector xpath="configurations/configuration/services/requiredservice"/>
			<xs:field xpath="@name"/>
		</xs:keyref>
		<!-- unique keys on type level -->
		<!-- key references in triggers / deliberation -->
		<!-- key references in configurations -->
		<!-- copied from jadex-component.xsd, prefixed with 'capa_' to avoid name clashes. -->
	</xs:element>
	
	<!-- the following declarations are copied and altered from component.xsd -->
	<xs:complexType name="agenttype">
		<xs:annotation>
			<xs:documentation>An agent type specifies the interface, the structure, content and behavior of an agent.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="startabletype">
				<xs:all>
					<xs:element name="imports" type="imports" minOccurs="0"/>
					<xs:element name="componenttypes" type="componenttypes" minOccurs="0"/>
					<xs:element name="services" type="services" minOccurs="0"/>
					<xs:element name="properties" type="properties" minOccurs="0"/>
					<xs:element name="configurations" type="aconfigurations" minOccurs="0"/>
					<xs:element name="capabilities" type="MCapabilityBase" minOccurs="0"/>
					<xs:element name="beliefs" type="MBeliefbase" minOccurs="0"/>
					<xs:element name="goals" type="MGoalbase" minOccurs="0"/>
					<xs:element name="plans" type="MPlanbase" minOccurs="0"/>
					<xs:element name="events" type="MEventbase" minOccurs="0"/>
					<xs:element name="expressions" type="MExpressionbase" minOccurs="0"/>
				</xs:all>
				<xs:attribute name="name" type="xs:string" use="required"/>
				<xs:attribute name="package" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- just copied to refer to new aconfiguration type -->
	<xs:complexType name="aconfigurations">
		<xs:annotation>
			<xs:documentation>
In the configurations section, predefined
 component configurations (i.e. component
				instances) can be defined.
			</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="configuration" type="aconfiguration" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
						A predefined component
						configuration.
					</xs:documentation>
				</xs:annotation>
				<xs:key name="aconfig_argument_name">
					<xs:selector xpath="arguments/argument"/>
					<xs:field xpath="@name"/>
				</xs:key>
				<xs:key name="aconfig_providedservice_key">
					<xs:selector xpath="services/providedservice"/>
					<xs:field xpath="@name|@class"/>
				</xs:key>
				<xs:unique name="aconfig_providedservice_name">
					<xs:selector xpath="services/providedservice"/>
					<xs:field xpath="@name"/>
				</xs:unique>
				<xs:key name="aconfig_requiredservice_name">
					<xs:selector xpath="services/requiredservice"/>
					<xs:field xpath="@name"/>
				</xs:key>
				<!-- Configuration unique constraints defined here, because elements need only be unique inside one config. -->
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="aconfiguration">
		<xs:annotation>
			<xs:documentation>A predefined application configuration.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="startabletype">
				<xs:all>
					<xs:element name="components" type="configcomponents" minOccurs="0"/>
					<xs:element name="services" type="configservices" minOccurs="0"/>
					<xs:element name="capabilities" type="MConfigCapabilitybase" minOccurs="0">
						<xs:key name="config_capability_name">
							<xs:selector xpath="initialcapability"/>
							<xs:field xpath="@ref"/>
						</xs:key>
					</xs:element>
					<xs:element name="beliefs" type="MConfigBeliefbase" minOccurs="0">
						<xs:unique name="config_belief_name">
							<xs:selector xpath="initialbelief|initialbeliefset"/>
							<xs:field xpath="@ref"/>
						</xs:unique>
						<xs:unique name="config_belief_cref">
							<xs:selector xpath="initialbelief|initialbeliefset"/>
							<xs:field xpath="@cref"/>
						</xs:unique>
					</xs:element>
					<xs:element name="goals" type="MConfigGoalbase" minOccurs="0"/>
					<xs:element name="plans" type="MConfigPlanbase" minOccurs="0"/>
					<xs:element name="events" type="MConfigEventbase" minOccurs="0"/>
				</xs:all>
				<xs:attribute name="name" type="xs:string" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	
	<xs:complexType name="MCapabilityBase">
		<xs:annotation>
			<xs:documentation>In the capabilities section arbitrary many capabilities can be declared. The functionality of a capability can be used within the agent resp. capability.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="capability" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>A capability usage declaration must include the local name of this capability (symbolic name) and the capability's type name (file) or an identifier for its identification.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="MCapabilityReference"/>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="MCapability">
		<xs:annotation>
			<xs:documentation>Base type for a capability.</xs:documentation>
		</xs:annotation>
		<xs:all>
			<xs:element name="imports" type="imports" minOccurs="0"/>
			<xs:element name="componenttypes" type="componenttypes" minOccurs="0"/>
			<xs:element name="services" type="services" minOccurs="0"/>
			<xs:element name="properties" type="properties" minOccurs="0"/>
			<xs:element name="configurations" type="aconfigurations" minOccurs="0"/>
			<xs:element name="capabilities" type="MCapabilityBase" minOccurs="0"/>
			<xs:element name="beliefs" type="MBeliefbase" minOccurs="0"/>
			<xs:element name="goals" type="MGoalbase" minOccurs="0"/>
			<xs:element name="plans" type="MPlanbase" minOccurs="0"/>
			<xs:element name="events" type="MEventbase" minOccurs="0"/>
			<xs:element name="expressions" type="MExpressionbase" minOccurs="0"/>
		</xs:all>
		<xs:attribute name="name" type="xs:string" use="required"/>
		<xs:attribute name="package" type="xs:string" use="optional"/>
	</xs:complexType>
	<xs:complexType name="MBeliefbase">
		<xs:annotation>
			<xs:documentation>Container for beliefs, beliefsets and corresponding references. In the beliefs section single-valued beliefs or multi-valued belief-references can be declared. Additionally references to exported or abstract beliefs of other capabilities can be specified.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MBase">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element name="belief" type="MBelief" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A single-valued piece of agent knowlegde.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="beliefset" type="MBeliefSet" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A multi-valued piece of agent knowlegde. </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="beliefref" type="MBeliefReference" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A concrete reference to a belief(ref) in another capability (concrete) or an abstract belief that needs assigment from the using capability. </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="beliefsetref" type="MBeliefSetReference" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A concrete reference to a beliefset(ref) in another capability (concrete) or an abstract beliefset that needs assigment from the using capability. </xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MGoalbase">
		<xs:annotation>
			<xs:documentation>Container for goals and corresponding references. In this section different kinds of goals and goal references can be specified. Supported goal types are perform, achieve, query, maintain and meta goals. Also refernces for all types can be specified.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MBase">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element name="performgoal" type="MPerformGoal" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A perform goal is goal that is directly associalted with actions to perform.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="achievegoal" type="MAchieveGoal" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>An achieve goal is a goal with a target state. To fulfill the goal the target state needs to be achieved.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="querygoal" type="MQueryGoal" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A query goal is a goal for retrieving information. It has  the implicit target consition that some result must be obtained for being succesfully achieved.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="maintaingoal" type="MMaintainGoal" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A maintain goal is a goal for maintaing some target state. Whenever this state gets violated plans are executed for the goal until the state is reestablished.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="metagoal" type="MMetaGoal" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A meta goal can be used for meta-level reasoning. Trigger of a meta-goal is another goal or event.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="performgoalref" type="MPerformGoalReference" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A concrete reference to a performgoal(ref) in another capability (concrete) or an abstract goal that needs assigment from the using capability. </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="achievegoalref" type="MAchieveGoalReference" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A concrete reference to an achievegoal(ref) in another capability (concrete) or an abstract goal that needs assigment from the using capability. </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="querygoalref" type="MQueryGoalReference" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A concrete reference to a querygoal(ref) in another capability (concrete) or an abstract goal that needs assigment from the using capability. </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="maintaingoalref" type="MMaintainGoalReference" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A concrete reference to a maintaingoal(ref) in another capability (concrete) or an abstract goal that needs assigment from the using capability. </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="metagoalref" type="MMetaGoalReference" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A concrete reference to a metagoal(ref) in another capability (concrete) or an abstract goal that needs assigment from the using capability. </xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MPlanbase">
		<xs:annotation>
			<xs:documentation>Container for plans. In this section plans can be specified.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MBase">
				<xs:sequence>
					<xs:element name="plan" type="MPlan" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A plan contains procedural knowledge for achieving goals or handling events. A plan consists of a head and body part. The head specifies the conditions under which the plan is applicabe whereas the body contains the concrete actions to perform.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MEventbase">
		<xs:annotation>
			<xs:documentation>Container for internal, message events and corresponding references. In this section internal and message events can be specified. Also references for both can be declared.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MBase">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element name="internalevent" type="MInternalEvent" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>An internal event is used for agent internal event notification. It represents a one-way information flow as the event thrower cannot obtain information about the result of event processing.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="messageevent" type="MMessageEvent" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A message event is used for inter-agent communication. </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="internaleventref" type="MInternalEventReference" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A concrete reference to an internalevent(ref) in another capability (concrete) or an abstract event that needs assigment from the using capability. </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="messageeventref" type="MMessageEventReference" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A concrete reference to an messageevent(ref) in another capability (concrete) or an abstract event that needs assigment from the using capability. </xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MExpressionbase">
		<xs:annotation>
			<xs:documentation>Container for expressions, conditions and corresponding references. In this section predefined expressions and conditions can be declared.  Also references for both can be declared.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MBase">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element name="expression" type="MExpression" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>An expression can be used for information querying. Parametrized expressions need explicitly to defined their input parameters.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="condition" type="MCondition" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A condition can be used for waiting for certain world states. Parametrized conditions need explicitly to defined their input parameters.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="expressionref" type="MExpressionReference" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A concrete reference to an expression(ref) in another capability (concrete) or an abstract expression that needs assigment from the using capability. </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="conditionref" type="MConditionReference" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>A concrete reference to a condition(ref) in another capability (concrete) or an abstract condition that needs assigment from the using capability. </xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MConfigurationbase">
		<xs:annotation>
			<xs:documentation>Container for configurations.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MConfigBase">
				<xs:sequence>
					<xs:element name="configuration" type="configuration" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Any number of configurations.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="default" type="xs:string" use="optional">
					<xs:annotation>
						<xs:documentation>The name of the default configuration to be used when no special configuration is selected.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MGoal" abstract="true" mixed="true">
		<xs:annotation>
			<xs:documentation>Base type for all goals.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MParameterElement">
				<xs:sequence>
					<xs:element name="unique" type="MUnique" minOccurs="0">
						<xs:annotation>
							<xs:documentation>If a goal is declared unique only one instance of this type is allowed being adopted at any one time. To determine if two goals are equal the type and parameters are used. Parameters that should not be considered can explicitly be excluded. </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="creationcondition" type="MBindingCondition" minOccurs="0">
						<xs:annotation>
							<xs:documentation>A condition that creates a new goal of the given type when triggered. If binding-parameters are used for each possible binding a new goal is created. </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="contextcondition" type="MInternalCondition" minOccurs="0">
						<xs:annotation>
							<xs:documentation>The context condition is checked during the whole execution time of a goal. If it becomes invalid the goal will become suspended and is not actively pursued until reactivation.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="dropcondition" type="MInternalCondition" minOccurs="0">
						<xs:annotation>
							<xs:documentation>If the dropcondition triggers the goal instance is dropped.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="recurcondition" type="MInternalCondition" minOccurs="0"/>
					<xs:element name="deliberation" type="MDeliberation" minOccurs="0">
						<xs:annotation>
							<xs:documentation>The goal deliberation setting for the easy deliberation strategy.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="publish" type="MPublish" minOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="retry" type="xs:boolean" default="true">
					<xs:annotation>
						<xs:documentation>The retry flag can be used to determine the behaviour on plan failures. If retry is turned on (by default it is on) and a plan fails to achieve the considered goal another plan from the applicables plan list will be chosen for execution.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="randomselection" type="xs:boolean" default="false">
					<xs:annotation>
						<xs:documentation>Random selection can be used to choose among applicable plans for a given goal randomly. If used this flag makes the order of plan declaration within the ADF unimportantly, i.e. only random selection is only applied to plans of the same priority and rank (cf. mlreasoning comment). The mechanism is implemented in the jadex.impl.DefaultMetaLevelReasoner.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="retrydelay" type="xs:long" default="0">
					<xs:annotation>
						<xs:documentation>With the retrydelay the delay between the failure of one plan and the execution of the next plan can be specified in milliseconds.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="exclude" default="when_tried">
					<xs:annotation>
						<xs:documentation>The exclude flag can be specified when a plan will be excluded from the applicable plan list. The default is when_tried, which means that a candidate is excluded independently of its state when executed one time for a goal. Other options are when_succeeded, when_failed and never.</xs:documentation>
					</xs:annotation>
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="never"/>
							<xs:enumeration value="when_tried"/>
							<xs:enumeration value="when_failed"/>
							<xs:enumeration value="when_succeeded"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
				<xs:attribute name="posttoall" type="xs:boolean" default="false">
					<xs:annotation>
						<xs:documentation>When post-to-all is set to true (default is false), a goal is dispatched to all candidates of the applicable plan list at once. This process will only happen one time regardless of the retry settings. A post-to-all goal has implicit or semantics meaning that if one plan achieves the goal all others will be terminated.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="recalculate" type="xs:boolean" default="true">
					<xs:annotation>
						<xs:documentation>When recalculate is set to false (default is true) the applicable candidates list will be calculated only once for the goal. Otherwise it will be recalculated whenever the goal should be processed.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="recur" type="xs:boolean" default="false"/>
				<xs:attribute name="recurdelay" type="xs:long" default="0"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MPerformGoal" mixed="true">
		<xs:annotation>
			<xs:documentation>A perform goal aims at executing actions.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MGoal"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MAchieveGoal" mixed="true">
		<xs:annotation>
			<xs:documentation>An achieve goal aims at bringing about a target state.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MGoal">
				<xs:sequence>
					<xs:element name="targetcondition" type="MInternalCondition" minOccurs="0">
						<xs:annotation>
							<xs:documentation>The target condition can be used to specify a desired world state representing goal success.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MQueryGoal" mixed="true">
		<xs:annotation>
			<xs:documentation>A query goal aims at retrieving information.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MGoal">
				<xs:sequence>
					<xs:element name="targetcondition" type="MInternalCondition" minOccurs="0">
						<xs:annotation>
							<xs:documentation>A query goal has the implicit target condition that none of its out parameters may null.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MMaintainGoal" mixed="true">
		<xs:annotation>
			<xs:documentation>A maintain goal aims at preserving a certain state.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MGoal">
				<xs:sequence>
					<xs:element name="maintaincondition" type="MInternalCondition">
						<xs:annotation>
							<xs:documentation>The mandatory maintain condition represents a world state that should be monitored and re-established whenever it gets violated. </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="targetcondition" type="MInternalCondition" minOccurs="0">
						<xs:annotation>
							<xs:documentation>A specalisation of the maintain condition taht should be re-established when the maintain condition is violated.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MMetaGoal">
		<xs:annotation>
			<xs:documentation>A meta goal can be used for meta-level reasoning.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MMetaGoalDummy">
				<xs:sequence>
					<xs:element name="trigger" type="MMetaGoalTrigger">
						<xs:annotation>
							<xs:documentation>The trigger for specifying for what kinds of events this meta goal should be used.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MMetaGoalDummy" abstract="true">
		<xs:annotation>
			<xs:documentation>Used only internally.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="MQueryGoal">
				<xs:sequence>
					<xs:sequence>
						<xs:element name="assignto" type="MAssign" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Assign this element to an abstract element of another capability.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
					<xs:choice minOccurs="0" maxOccurs="unbounded">
						<xs:element name="parameter" type="MParameter" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Any number of parameters.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="parameterset" type="MParameterSet" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Any number of parameter sets.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:choice>
					<xs:sequence>
						<xs:element name="contextcondition" type="MInternalCondition" minOccurs="0">
							<xs:annotation>
								<xs:documentation>The context condition is checked during the whole execution time of a goal. If it becomes invalid the goal will become suspended and is not actively pursued until reactivation.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="dropcondition" type="MInternalCondition" minOccurs="0">
							<xs:annotation>
								<xs:documentation>If the dropcondition triggers the goal instance is dropped.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="deliberation" type="MDeliberation" minOccurs="0">
							<xs:annotation>
								<xs:documentation>The goal deliberation setting for the easy deliberation strategy.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
					<xs:sequence>
						<xs:element name="targetcondition" type="MInternalCondition" minOccurs="0">
							<xs:annotation>
								<xs:documentation>A query goal has the implicit target condition that none of its out parameters may null.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MPlan" mixed="true">
		<xs:annotation>
			<xs:documentation>A plan contains procedural knowledge. It consists of a plan head and a plan body.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MElement">
				<xs:sequence>
                    <xs:choice minOccurs="0" maxOccurs="unbounded">
						<xs:element name="parameter" type="MPlanParameter" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>An arbitrary number of plan parameters.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="parameterset" type="MPlanParameterSet" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>An arbitrary number of plan parameter sets.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:choice>
					<xs:element name="body" type="MPlanBody">
						<xs:annotation>
							<xs:documentation>The plan body. If it is a normal plan the body is interpreted as an expression that must be evaluable to a plan object. If it is an inline plan the body (passed, failed, aborted) code is directly contained in this body specification.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="trigger" type="MPlanTrigger" minOccurs="0">
						<xs:annotation>
							<xs:documentation>The trigger is used to determine when a plan is applicable for a given event or goal.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="precondition" type="MInternalExpression" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Only when the precondition holds a plan can be selected for execution. During the execution of the plan the precondition is not checked any more.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="contextcondition" type="MInternalCondition" minOccurs="0">
						<xs:annotation>
							<xs:documentation>The context condition of a plan must be valid during the  whole time of plan execution. If it becomes invalid the plan will immediately be aborted.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="waitqueue" type="MTrigger" minOccurs="0">
						<xs:annotation>
							<xs:documentation>The waitque allows a plan instance to receive events even if it is currently running. With the waitqueue filter a plan instance can declare general interest in certain kinds of events.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="priority" type="xs:int" use="optional" default="0">
					<xs:annotation>
						<xs:documentation>The priority can be used for controlling the plan selection process (default priority is 0). Plans with higher priority have precedence for plans with lower priority.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MPlanBody" mixed="true">
		<xs:annotation>
			<xs:documentation>The plan body contains the code (actions) to execute.</xs:documentation>
		</xs:annotation>
		<xs:attribute name="type" use="optional">
			<xs:annotation>
				<xs:documentation>
					The type of the plan body. Default is standard. If
					mobile agents (migration) is required mobile plans
					should be used. Mobile plan do not require their own
					thread.
				</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:string"/>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="class" type="xs:string"/>
		<xs:attribute name="impl" type="xs:string"/>
		<xs:attribute name="service" type="xs:string"/>
		<xs:attribute name="method" type="xs:string"/>
	</xs:complexType>
	<xs:complexType name="MTypedElement" abstract="true" mixed="true">
		<xs:annotation>
			<xs:documentation>Base type for single-valued elements with a type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MReferenceableElement">
				<xs:attribute name="class" type="xs:string" use="required">
					<xs:annotation>
						<xs:documentation>The required Java class of the fact. Used for type checking objects that are asserted as facts.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="updaterate" type="xs:long" use="optional" default="0">
					<xs:annotation>
						<xs:documentation>For dynamic expressions the update rate defines in what intervals the fact will be re-evaluated. The default update rate is set to 0.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transient" type="xs:boolean" use="optional" default="false">
					<xs:annotation>
						<xs:documentation>Transient beliefs or prameter values are not retained, when persisting or migrating an agent. This is useful e.g. when a value class is not serializable.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="evaluationmode" use="optional" default="static">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="static"/>
							<xs:enumeration value="push"/>
							<xs:enumeration value="pull"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MTypedElementSet" abstract="true" mixed="true">
		<xs:annotation>
			<xs:documentation>Base type for multi-valued elements with a type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MReferenceableElement">
				<xs:attribute name="class" type="xs:string" use="required">
					<xs:annotation>
						<xs:documentation>The required Java class of the fact. Used for type checking objects that are asserted as facts.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="updaterate" type="xs:long" use="optional" default="0">
					<xs:annotation>
						<xs:documentation>For dynamic expressions the update rate defines in what intervals the fact will be re-evaluated. The default update rate is set to 0.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="transient" type="xs:boolean" use="optional" default="false">
					<xs:annotation>
						<xs:documentation>Transient beliefs or prameter values are not retained, when persisting or migrating an agent. This is useful e.g. when a value class is not serializable.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="evaluationmode" use="optional" default="static">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="static"/>
							<xs:enumeration value="push"/>
							<xs:enumeration value="pull"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MParameter">
		<xs:annotation>
			<xs:documentation>A parameter represents a single-valued piece of information belonging to some parameter element.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="MPlanParameter">
				<xs:sequence>
					<xs:sequence>
						<xs:element name="assignto" type="MAssign" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Assign this element to an abstract element of another capability.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
					<xs:choice>
						<xs:element name="value" type="MInternalExpression" minOccurs="0">
							<xs:annotation>
								<xs:documentation>An expression that represents the default value. Per default it is static, i.e. it is only evalued only once on creation. </xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="bindingoptions" type="MInternalExpression" minOccurs="0"/>
					</xs:choice>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MParameterSet">
		<xs:annotation>
			<xs:documentation>A parameter set represents a multi-valued piece of information belonging to some parameter element.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:restriction base="MPlanParameterSet">
				<xs:sequence>
					<xs:sequence>
						<xs:element name="assignto" type="MAssign" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Assign this element to an abstract element of another capability.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
					<xs:choice>
						<xs:element name="value" type="MInternalExpression" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>An expression that evaluated to a default value. Only static values are allowed, i.e. it is only evaluated once on creation.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="values" type="MInternalExpression" minOccurs="0">
							<xs:annotation>
								<xs:documentation>An expression that is evaluated to a set of default values. Per default it is static, i.e. it is only evalued only once on creation. </xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:choice>
				</xs:sequence>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MBelief" mixed="true">
		<xs:annotation>
			<xs:documentation>
				A belief represents a single-valued piece of
				information.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MTypedElement">
				<xs:sequence>
					<xs:element name="fact" type="MFactType" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Initial value for a belief. Per default it is static, i.e. it is only evalued only once on creation.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="argument" type="xs:boolean"/>
				<xs:attribute name="result" type="xs:boolean"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- Dummy type without refinements to avoid xs:type attribute on fact. -->
	<xs:complexType name="MFactType">
		<xs:complexContent>
			<xs:extension base="MInternalExpression"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MBeliefSet" mixed="true">
		<xs:annotation>
			<xs:documentation>
				A belief represents a multi-valued piece of information.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MTypedElementSet">
				<xs:choice>
					<xs:element name="fact" type="MInternalExpression" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>An expression that is evaluated to a default value. Only static values are allowed, i.e. it is only evaluated once on agent creation.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="facts" type="MInternalExpression" minOccurs="0">
						<xs:annotation>
							<xs:documentation>An expression that is evaluated to a set of default value. Only static values are allowed, i.e. it is only evaluated once on agent creation.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:choice>
				<xs:attribute name="argument" type="xs:boolean"/>
				<xs:attribute name="result" type="xs:boolean"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MPlanParameter" mixed="true">
		<xs:annotation>
			<xs:documentation>Parameter for a plan. Additionally allows mappings being defined.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MTypedElement">
				<xs:choice>
					<xs:element name="value" type="MInternalExpression" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
								An expression that is the default value.
							</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="bindingoptions" type="MInternalExpression" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
								From a set of binding option values one
								concrete is selected per plan instance.
								If a plan with binding options is
								created for each possible binding value
								a new plan instance is created.
							</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:choice minOccurs="0" maxOccurs="unbounded">
						<xs:element name="goalmapping" type="MAssign" minOccurs="0">
							<xs:annotation>
								<xs:documentation>
									This parameter is considered as a
									proxy. It is mapped to another
									parameter in a goal.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="internaleventmapping" type="MAssign" minOccurs="0">
							<xs:annotation>
								<xs:documentation>
									This parameter is considered as a
									proxy. It is mapped to another
									parameter in an internal event.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="messageeventmapping" type="MAssign" minOccurs="0">
							<xs:annotation>
								<xs:documentation>
									This parameter is considered as a
									proxy. It is mapped to another
									parameter in a message event.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:choice>
				</xs:choice>
				<xs:attribute name="optional" type="xs:boolean" use="optional" default="false">
					<xs:annotation>
						<xs:documentation>If a parameter is declared optional (default is false), it need not to have a value (can null).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="direction" use="optional" default="in">
					<xs:annotation>
						<xs:documentation>The direction can be used to explicitly declare e.g. result parameters (out) or parameters that are both (inout). Per default parameters are in.</xs:documentation>
					</xs:annotation>
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="in"/>
							<xs:enumeration value="out"/>
							<xs:enumeration value="inout"/>
							<xs:enumeration value="fixed"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MPlanParameterSet" mixed="true">
		<xs:annotation>
			<xs:documentation>Parameter set for a plan. Additionally allows mappings being defined.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MTypedElementSet">
				<xs:choice>
					<xs:element name="value" type="MInternalExpression" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element name="values" type="MInternalExpression" minOccurs="0"/>
					<xs:sequence>
						<xs:element name="internaleventmapping" type="MAssign" minOccurs="0" maxOccurs="unbounded"/>
						<xs:element name="messageeventmapping" type="MAssign" minOccurs="0" maxOccurs="unbounded"/>
						<xs:element name="goalmapping" type="MAssign" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:choice>
				<xs:attribute name="optional" type="xs:boolean" use="optional" default="false">
					<xs:annotation>
						<xs:documentation>If a parameter is declared optional (default is false), it need not to have a value (can have 0 values).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="direction" use="optional" default="in">
					<xs:annotation>
						<xs:documentation>The direction can be used to explicitly declare e.g. result parameters (out) or parameters that are both (inout). Per default parameters are in.</xs:documentation>
					</xs:annotation>
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="in"/>
							<xs:enumeration value="out"/>
							<xs:enumeration value="inout"/>
							<xs:enumeration value="fixed"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MExpression" mixed="true">
		<xs:annotation>
			<xs:documentation>
													A piece a program
													code that is
													evaluated.
									</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MReferenceableElement">
				<xs:attribute name="class" type="xs:string" use="optional">
					<xs:annotation>
						<xs:documentation>
																									The
																									required
																									Java
																									class
																									of
																									the
																									expression.
																									Used
																									for
																									type
																									checking
																									the
																									evaluation
																									result.
																					</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="language" type="xs:string" use="optional"/>
				<xs:attribute name="variable" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MInternalExpression" mixed="true">
		<xs:annotation>
			<xs:documentation>A piece a program code that is evaluated.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MElementNoName">
				<xs:attribute name="class" type="xs:string" use="optional">
					<xs:annotation>
						<xs:documentation>
							The required Java class of the expression. Used for type checking the evaluation result.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="language" type="xs:string" use="optional"/>
				<xs:attribute name="variable" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MExpressionParameter">
		<xs:annotation>
			<xs:documentation>A user-defined parameter for an expression, e.g. for parametrized queries.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MElement">
				<xs:attribute name="class" type="xs:string" use="required">
					<xs:annotation>
						<xs:documentation>The Java class of the user-defined parameter.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MCondition" mixed="true">
		<xs:annotation>
			<xs:documentation>
				An expression that is monitored.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MExpression">
				<xs:attribute name="beliefs" type="xs:string"
					use="optional">
					<xs:annotation>
						<xs:documentation>
							The beliefs on which the condition depends.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="parameters" type="xs:string"
					use="optional">
					<xs:annotation>
						<xs:documentation>
							The parameters (i.e. for goal and plan
							conditions) on which the condition depends.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="rawevents" type="xs:string"
					use="optional">
					<xs:annotation>
						<xs:documentation>
							Allows specifying raw events (in internal ECA format) on which the condition depends.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MInternalCondition" mixed="true">
		<xs:annotation>
			<xs:documentation>For conditions that are not conatined in the expressionbase. Cannot be exported.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MInternalExpression">
				<xs:attribute name="beliefs" type="xs:string"
					use="optional">
					<xs:annotation>
						<xs:documentation>
							The beliefs on which the condition depends.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="parameters" type="xs:string"
					use="optional">
					<xs:annotation>
						<xs:documentation>
							The parameters (i.e. for goal and plan
							conditions) on which the condition depends.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="rawevents" type="xs:string"
					use="optional">
					<xs:annotation>
						<xs:documentation>
							Allows specifying raw events (in internal ECA format) on which the condition depends.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MCapabilityReference">
		<xs:annotation>
			<xs:documentation>Describes and defines an included capability.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MElement">
				<xs:attribute name="file" type="xs:string" use="required">
					<xs:annotation>
						<xs:documentation>The capability to include. The file can be either referenced by an unqualified or qualified name, e.g. name or package.name, or by a filename relative to the classpath, e.g., package/name.capability.xml. Abstract capabilities like the DF capability have to be referenced by the fully qualified name (i.e., jadex.planlib.DF), because these capabilities are resolved by this identifier using the platform configuration.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MElement" abstract="true">
		<xs:annotation>
			<xs:documentation>Base type for all model elements.</xs:documentation>
		</xs:annotation>
		<xs:attribute name="name" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The elements name.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="MBase" abstract="true">
		<xs:annotation>
			<xs:documentation>Base type for all bases, e.g. beliefbase, planbase, goalbase, etc.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MElementNoName"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MEvent" abstract="true" mixed="true">
		<xs:annotation>
			<xs:documentation>Base type for all events.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MParameterElement">
				<xs:attribute name="posttoall" type="xs:boolean" use="optional">
					<xs:annotation>
						<xs:documentation>When post-to-all is set to true (default is true only for internal events), an event is dispatched to all candidates of the applicable plan list at once. </xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="randomselection" type="xs:boolean" use="optional">
					<xs:annotation>
						<xs:documentation>Random selection can be used to choose among applicable plans for a given goal randomly. If used this flag makes the order of plan declaration within the ADF unimportantly, i.e. only random selection is only applied to plans of the same priority and rank (cf. mlreasoning comment). The mechanism is implemented in the jadex.impl.DefaultMetaLevelReasoner.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MInternalEvent" mixed="true">
		<xs:annotation>
			<xs:documentation>An internal event is used for agent internal event notification.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MEvent"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MMessageEvent" mixed="true">
		<xs:annotation>
			<xs:documentation>A message event is used for inter-agent communication. </xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MEvent">
				<xs:sequence>
					<xs:element name="match" type="MInternalExpression" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Expression stating in what case a message matches the given event.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="direction" use="optional" default="send_receive">
					<xs:annotation>
						<xs:documentation>Specifies the direction of the message. Possible values are send, receive and send_receive.</xs:documentation>
					</xs:annotation>
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="send"/>
							<xs:enumeration value="receive"/>
							<xs:enumeration value="send_receive"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
				<xs:attribute name="type" type="xs:string" use="required">
					<xs:annotation>
						<xs:documentation>The message type defines the predefined names and types of parameters. Possible values are fipa.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MParameterElement" abstract="true" mixed="true">
		<xs:annotation>
			<xs:documentation>Base type for elements that can have parameters and parameter sets.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MReferenceableElement">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element name="parameter" type="MParameter" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Any number of parameters.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="parameterset" type="MParameterSet" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Any number of parameter set elements.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MAssign">
		<xs:annotation>
			<xs:documentation>Used to define a reference to an element from another capability.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MElementNoName">
				<xs:attribute name="ref" type="xs:string" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MTrigger">
		<xs:annotation>
			<xs:documentation>Base trigger type allows reaction on goals, internal and message events and filters. All declared elements are considered as OR combined.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MElementNoName">
				<xs:sequence>
					<xs:choice minOccurs="0" maxOccurs="unbounded">
						<xs:element name="internalevent" type="MReference" minOccurs="0">
							<xs:annotation>
								<xs:documentation>
								Any number of internal events that are
								triggers.
							</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="messageevent" type="MReference" minOccurs="0">
							<xs:annotation>
								<xs:documentation>
								Any number of message events that are
								triggers.
							</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="goalfinished" type="MReference" minOccurs="0">
							<xs:annotation>
								<xs:documentation>
								Any number of goals that are triggers.
							</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:choice>
					<xs:element name="filter" type="MInternalExpression" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
								Deprecated. Can be used to specify an
								arbitrary complex filter expression that
								must evaluate to a IFilter and will be
								used to check if triggers.
							</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MReference">
		<xs:annotation>
			<xs:documentation>Reference to another element. Used in trigger to match an event or goal.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MReferenceNoMatch">
				<xs:sequence>
					<xs:element name="match" type="MInternalExpression" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Match expression to state in which exact cases a match exists.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MReferenceNoMatch">
		<xs:annotation>
			<xs:documentation>Reference to another element. Used in trigger to match a belief or beliefset.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MElementNoName">
				<xs:attribute name="ref" type="xs:string">
					<xs:annotation>
						<xs:documentation>The name of an element in the local capability. One of 'ref' or 'cref' is required.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="cref" type="xs:string">
					<xs:annotation>
						<xs:documentation>A reference to an element in another capability (e.g. 'mycap.mybelief'). One of 'ref' or 'cref' is required.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MBindingCondition" mixed="true">
		<xs:annotation>
			<xs:documentation>A condition used for binding purposes (multiple variable assignmnets).</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MInternalCondition"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MUnique">
		<xs:annotation>
			<xs:documentation>Uniqueness settings for goals. Excluded parameters will not affect if goals are considered equal.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MElementNoName">
				<xs:sequence>
					<xs:element name="exclude" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Any number of excluded parameters. </xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:attribute name="parameterref" type="xs:string" use="required"/>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MReferenceableElement" abstract="true" mixed="true">
		<xs:annotation>
			<xs:documentation>Base type for elements contained in bases. Exported elements can be used in outer capabilities.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MElement">
				<xs:sequence>
					<xs:element name="assignto" type="MAssign" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Assign this element to an abstract element of another capability.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="exported" use="optional" default="false">
					<xs:annotation>
						<xs:documentation>If an element is exported it can be referenced from an outer capability. The default for this attribute is false. A shielded attribute is only visible outside, when created there, instances created in the inner capability will not be visible to the outer capability.</xs:documentation>
					</xs:annotation>
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="true"/>
							<xs:enumeration value="false"/>
							<xs:enumeration value="shielded"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MElementReference" abstract="true" mixed="true">
		<xs:annotation>
			<xs:documentation>Base type for element references, i.e. elements that reference others.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MReferenceableElement">
				<xs:choice>
					<xs:element name="concrete" type="MAssign">
						<xs:annotation>
							<xs:documentation>A concrete reference to an element that is conatined in some included subcapability. Dot notation is used for referencing the other element, e.g. subcapname.elemname </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="abstract">
						<xs:annotation>
							<xs:documentation>The reference is abstract. This means that an outer capability can assign an element to this reference. If required this assignment is needed. Otherwise the element can potentially be unbounded.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:attribute name="required" type="xs:boolean" use="optional" default="true">
								<xs:annotation>
									<xs:documentation>If an abstract element is required, a capability wants to use this capability is forced to assign an element to this abstract reference. Per default abstract alements are required.</xs:documentation>
								</xs:annotation>
							</xs:attribute>
						</xs:complexType>
					</xs:element>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- 
	<xs:complexType name="MTypedElementReference" abstract="true" mixed="true">
		<xs:annotation>
			<xs:documentation>Reference to a typed element.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MElementReference">
				<xs:attribute name="class" type="xs:string">
					<xs:annotation>
						<xs:documentation>The class of the contained value. In the reference this value can be overridden to allow specializations for derived types.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MTypedElementSetReference" abstract="true" mixed="true">
		<xs:annotation>
			<xs:documentation>Reference to a typed element set.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MElementReference">
				<xs:attribute name="class" type="xs:string">
					<xs:annotation>
						<xs:documentation>The class of the contained value. In the reference this value can be overridden to allow specializations for derived types.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MParameterReference" mixed="true">
		<xs:annotation>
			<xs:documentation>Reference to a parameter.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MTypedElementReference"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MParameterSetReference" mixed="true">
		<xs:annotation>
			<xs:documentation>Reference to a parameter set.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MTypedElementSetReference"/>
		</xs:complexContent>
	</xs:complexType>
	 -->
	<xs:complexType name="MBeliefReference" mixed="true">
		<xs:annotation>
			<xs:documentation>Reference to a belief.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<!-- <xs:extension base="MTypedElementReference"> -->
			<xs:extension base="MElementReference">
				<xs:attribute name="argument" type="xs:boolean"/>
				<xs:attribute name="result" type="xs:boolean"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MBeliefSetReference" mixed="true">
		<xs:annotation>
			<xs:documentation>
				Reference to a belief set.
			</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<!-- <xs:extension base="MTypedElementSetReference"> -->
			<xs:extension base="MElementReference">
				<xs:attribute name="argument" type="xs:boolean"/>
				<xs:attribute name="result" type="xs:boolean"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- 
	<xs:complexType name="MParameterElementReference" abstract="true" mixed="true">
		<xs:annotation>
			<xs:documentation>Reference to a parameter element.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MElementReference">
				<xs:sequence>
					<xs:element name="parameterref" type="MParameterReference" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Any number of parameter references.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="parametersetref" type="MParameterSetReference" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Any number of parameter set references.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	 -->
	<xs:complexType name="MGoalReference" mixed="true">
		<xs:annotation>
			<xs:documentation>Reference to a goal.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<!-- <xs:extension base="MParameterElementReference">  -->
			<xs:extension base="MElementReference">
				<xs:sequence>
					<xs:element name="deliberation" type="MDeliberation" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MPerformGoalReference" mixed="true">
		<xs:annotation>
			<xs:documentation>Reference to a goal.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MGoalReference"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MAchieveGoalReference" mixed="true">
		<xs:annotation>
			<xs:documentation>Reference to an achieve goal.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MGoalReference"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MQueryGoalReference" mixed="true">
		<xs:annotation>
			<xs:documentation>Reference to a query goal.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MGoalReference"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MMetaGoalReference" mixed="true">
		<xs:annotation>
			<xs:documentation>Reference to a meta goal.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MGoalReference"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MMaintainGoalReference" mixed="true">
		<xs:annotation>
			<xs:documentation>Reference to a maintain goal.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MGoalReference"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MEventReference" mixed="true">
		<xs:annotation>
			<xs:documentation>Reference to an event.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MElementReference"/>
			<!-- <xs:extension base="MParameterElementReference"/> -->
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MInternalEventReference" mixed="true">
		<xs:annotation>
			<xs:documentation>Reference to an internal event.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MEventReference"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MMessageEventReference" mixed="true">
		<xs:annotation>
			<xs:documentation>Reference to a message event.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MEventReference"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MPlanReference" mixed="true">
		<xs:annotation>
			<xs:documentation>Reference to a plan. Not yet used.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MElementReference"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MExpressionReference" mixed="true">
		<xs:annotation>
			<xs:documentation>Reference to an expression.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MElementReference"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MConditionReference" mixed="true">
		<xs:annotation>
			<xs:documentation>Reference to a condition.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MExpressionReference"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MConfigElement" abstract="true">
		<xs:annotation>
			<xs:documentation>Base type for configuration elements.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MElementNoName">
				<xs:attribute name="name" type="xs:string" use="optional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MConfigReferenceableElement" abstract="true">
		<xs:annotation>
			<xs:documentation>Base type for referenceable configuration elements.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MConfigElement">
				<xs:attribute name="ref" type="xs:string">
					<xs:annotation>
						<xs:documentation>The name of an element in the local capability. One of 'ref' or 'cref' is required.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="cref" type="xs:string">
					<xs:annotation>
						<xs:documentation>A reference to an element in another capability (e.g. 'mycap.mygoal'). One of 'ref' or 'cref' is required.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MConfigParameterElement" abstract="true">
		<xs:annotation>
			<xs:documentation>Base type for parameter configuration elements.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MConfigReferenceableElement">
				<xs:choice minOccurs="0" maxOccurs="unbounded">
					<xs:element name="parameter" type="MConfigParameter" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>An expression that is once evaluated to the initial parameter value.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="parameterset" type="MConfigParameterSet" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>An expression that is once evaluated to the initial parameter set values.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MConfigGoal">
		<xs:annotation>
			<xs:documentation>A goal instance that is created on capability or agent creation or deletion.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MConfigParameterElement"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MConfigPlan">
		<xs:annotation>
			<xs:documentation>A plan instance that is created on capability or agent creation or deletion.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MConfigParameterElement"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MConfigMessageEvent">
		<xs:annotation>
			<xs:documentation>A message event instance that is created on capability or agent creation or deletion.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MConfigParameterElement"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MConfigInternalEvent">
		<xs:annotation>
			<xs:documentation>An internal event instance that is created on capability or agent creation or deletion.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MConfigParameterElement"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MConfigBelief">
		<xs:annotation>
			<xs:documentation>A belief that is initialized with a defined value on capability or agent creation.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MConfigReferenceableElement">
				<xs:sequence>
					<xs:element name="fact" type="MInternalExpression">
						<xs:annotation>
							<xs:documentation>An expression that is once evaluated to the initial belief value.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MConfigBeliefSet">
		<xs:annotation>
			<xs:documentation>A belief that is initialized with defined values on capability or agent creation.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MConfigReferenceableElement">
				<xs:choice>
					<xs:element name="fact" type="MInternalExpression" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>An expression that is once evaluated to the initial belief value.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="facts" type="MInternalExpression">
						<xs:annotation>
							<xs:documentation>An expression that is once evaluated to the initial belief set values.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MConfigBase" abstract="true">
		<xs:annotation>
			<xs:documentation>Base type for configuration bases.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MElementNoName"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MConfigBeliefbase">
		<xs:annotation>
			<xs:documentation>Container for configuration beliefs.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MConfigBase">
				<xs:sequence>
					<xs:element name="initialbelief" type="MConfigBelief" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Any number of initially customized beliefs.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="initialbeliefset" type="MConfigBeliefSet" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Any number of initially customized belief sets.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MConfigCapabilitybase">
		<xs:annotation>
			<xs:documentation>Container for configuration capabilitiers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MConfigBase">
				<xs:sequence>
					<xs:element name="initialcapability" type="MConfigCapability" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Any number of initially set up capabilities. Note that they have to reference a declared capability and can only change their initialstate.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MConfigGoalbase">
		<xs:annotation>
			<xs:documentation>Container for configuration goals.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MConfigBase">
				<xs:sequence>
					<xs:element name="initialgoal" type="MConfigGoal" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Any number of initially created goals.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="endgoal" type="MConfigGoal" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Any number of initially created goals.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MConfigPlanbase">
		<xs:annotation>
			<xs:documentation>Container for configuration plans.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MConfigBase">
				<xs:sequence>
					<xs:element name="initialplan" type="MConfigPlan" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Any number of initially created plans.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="endplan" type="MConfigPlan" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Any number of initially created plans.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MConfigEventbase">
		<xs:annotation>
			<xs:documentation>Container for configuration events.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MConfigBase">
				<xs:sequence>
					<xs:element name="initialinternalevent" type="MConfigInternalEvent" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Any number of initially created internal events.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="initialmessageevent" type="MConfigMessageEvent" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Any number of initially created message events.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="endinternalevent" type="MConfigInternalEvent" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Any number of initially created internal events.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="endmessageevent" type="MConfigMessageEvent" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Any number of initially created message events.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MConfigParameter">
		<xs:annotation>
			<xs:documentation>A configuration parameter holds an initial value for a parameter of a configuration element.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MConfigReferenceableElement">
				<xs:sequence>
					<xs:element name="value" type="MInternalExpression">
						<xs:annotation>
							<xs:documentation>An expression that resolves to a single value.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MConfigParameterSet">
		<xs:annotation>
			<xs:documentation>A configuration parameter set holds initial values for a parameter set of a configuration element.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MConfigReferenceableElement">
				<xs:choice>
					<xs:element name="value" type="MInternalExpression" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>An expression that evaluates to a single value.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="values" type="MInternalExpression">
						<xs:annotation>
							<xs:documentation>An expression that resolves to a set of values. Supported are iterators, enumerations, java.util.Collections, java.util.Maps, arrays.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MConfigCapability">
		<xs:annotation>
			<xs:documentation>A capability that is initialized with a defined configuration on capability or agent creation.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MConfigReferenceableElement">
				<xs:attribute name="configuration" type="xs:string" use="required">
					<xs:annotation>
						<xs:documentation>The name of the initialstate that should be used for the initial capability.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MPlanTrigger">
		<xs:annotation>
			<xs:documentation>The trigger for plans also reacting on goal process events, conditions, belief and belief set changes.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MTrigger">
				<xs:sequence>
					<xs:element name="condition" minOccurs="0">
						<xs:complexType mixed="true">
							<xs:complexContent mixed="true">
								<xs:extension base="MBindingCondition"/>
							</xs:complexContent>
						</xs:complexType>
					</xs:element>
					<xs:choice minOccurs="0" maxOccurs="unbounded">
						<xs:element name="goal" type="MReference" minOccurs="0">
							<xs:annotation>
								<xs:documentation>
								Any number of goals that are triggers.
							</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="factadded" type="MReferenceNoMatch" minOccurs="0"/>
						<xs:element name="factremoved" type="MReferenceNoMatch" minOccurs="0"/>
						<xs:element name="factchanged" type="MReferenceNoMatch" minOccurs="0"/>
					</xs:choice>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MMetaGoalTrigger">
		<xs:annotation>
			<xs:documentation>The trigger for meta goals also reacting on goal process events.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MTrigger">
				<xs:sequence>
					<xs:element name="goal" type="MReference" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Any number of goals that are triggers.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MStaticValue" mixed="true">
		<xs:annotation>
			<xs:documentation>For a value that is only once computed.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:restriction base="MExpression">
				<xs:sequence>
					<xs:element name="assignto" type="MAssign" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Assign this element to an abstract element of another capability.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="exported" use="prohibited"/>
			</xs:restriction>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MInhibits" mixed="true">
		<xs:annotation>
			<xs:documentation>Easy deliberation settings for goals (inhibitions). For an inhibition with the ref attribute the name of the inhibited goal can be specified. With the inhibit attribute it can optinally also specified in which state the goal has to be to inhibit the other.</xs:documentation>
		</xs:annotation>
		<xs:complexContent mixed="true">
			<xs:extension base="MInternalExpression">
				<xs:attribute name="ref" type="xs:string">
					<xs:annotation>
						<xs:documentation>The name of a goal in the local capability to be inhibited. One of 'ref' or 'cref' is required.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="cref" type="xs:string">
					<xs:annotation>
						<xs:documentation>A reference to a goal in another capability (e.g. 'mycap.mygoal') to be inhibited. One of 'ref' or 'cref' is required.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="inhibit" use="optional" default="when_active">
					<xs:annotation>
						<xs:documentation>In which state other goals should be inhibited. The default is when_active. For maintain this should normally be changed to when_in_process as maintain goals are homeostatic and active longer than other goal types.</xs:documentation>
					</xs:annotation>
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="when_in_process"/>
							<xs:enumeration value="when_active"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MDeliberation">
		<xs:annotation>
			<xs:documentation>Easy deliberation settings for goals (cardinality and inhibitions).</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="MElementNoName">
				<xs:sequence>
					<xs:element name="inhibits" type="MInhibits" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Any number of inhibitions can be specified. One inhibition specifies under which circumstances a referenced goal is inhibited.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="cardinalityone" type="xs:boolean" use="optional" default="false"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MElementNoName" abstract="true">
		<xs:annotation>
			<xs:documentation>Base element without name.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="MPublish">
		<xs:annotation>
			<xs:documentation>Goal delegation element. </xs:documentation>
		</xs:annotation>
		<xs:attribute name="class" type="xs:string" use="required"/>
		<xs:attribute name="method" type="xs:string" use="required"/>
	</xs:complexType>
</xs:schema>
