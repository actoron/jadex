<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>Web JCC</title>
		
		<link rel="icon" href="favicon.ico" type="image/x-icon">
		<link rel="stylesheet" href="css/style.css">
		
		<script type="text/javascript" src="libs/axios_0.18.0.js"></script>
		<script type="text/javascript" src="libs/riot_3.13.2.js"></script>
		<script type="text/javascript" src="libs/route_3.1.4.js"></script>
		<script type="riot/tag" src="tags/app.tag"></script>
		<script type="riot/tag" src="tags/about.tag"></script>
		<script type="riot/tag" src="tags/imprint.tag"></script>
		<script type="riot/tag" src="tags/privacy.tag"></script>
		<script type="riot/tag" src="tags/platforms.tag"></script>
		<script type="riot/tag" src="tags/platform.tag"></script>
		
		<link rel="stylesheet" href="libs/bootstrap_4.1.0.min.css">
		<script src="libs/jquery_3.3.1.js"></script>
		<script src="libs/popper_1.14.0.min.js"></script>
		<script src="libs/bootstrap_4.1.0.min.js"></script>
		
		<!-- <script src="libs/jstree_3.2.1.min.js"></script>
		<link rel="stylesheet" href="libs/jstree_3.2.1.min.css" /> -->
	</head>
	<body>
		<app></app>
		
		<script type="text/javascript">
			// Add a format method for Date 
			Date.prototype.yyyymmdd = function(sep) {
				var mm = (this.getMonth() + 1).toString();
				var dd = this.getDate().toString();
				return [this.getFullYear(), (mm.length===2 ? '' : '0')+mm, (dd.length===2 ? '' : '0')+dd].join(sep? sep: '');
			};
			//var now = new Date();
			//alert(now.yyyymmdd()+" "+now.yyyymmdd('-'));
			
			Array.prototype.equals = function(a, b) {
				if (a === b) return true;
				if (a == null || b == null) return false;
				if (a.length != b.length) return false;
			
				for (var i = 0; i < a.length; ++i) {
			    	if (a[i] !== b[i]) return false;
			  	}
			  	return true;
			};
			
			// not using var to set a global variable
			PROMISE_DOME = Promise.resolve("Dummy response to keep the console quiet");
			
			
			
			// https://riot.js.org/api/
	    	// Note: users of In-browser compilation will need to wrap calls to riot.mount in riot.compile in order to get returned tag instances.
	    	// Without this, calls to riot.mount will return undefined.
			riot.compile(function() {
				var Store = function() {
					riot.observable(this);
					this.language = "en";
					this.switchLanguage = function() 
					{
						if(this.language=="en") {
		 		    		this.language="de";
						} 
						else {
		 		    		this.language="en";
						}
						this.trigger('language', this.language);  
						//console.log(this.language);
					};
				};
				riot.store = new Store();
				
				var cnt = 0;
				
				var langmixin = {
					//self: null,
					//lang: "en",
					messages: {
			    		en: {
			   				message: {
			   					home: "Home",
			   					privacy: "Privacy",
			   					imprint: "Imprint",
			   					about: "About"
			    			}
			  			},
				    	de: {
							message: {
								home: "Home",
								privacy: "Datenschutz",
			   					imprint: "Impressum",
								about: "Ãœber"
							}
			  			}
					},
					init: function() {
						// var must not be omitted here. otherwise it will automatically create a global variable
						var self = this;
						//console.log("created: "+self.id);
						self.id = cnt++;
						//console.log("created: "+self.id);
						riot.store.on('language', function(l) {
							self.lang = l;
							//console.log("lang: "+l+" "+self.id);
							self.update();
						});
						self.lang = riot.store.language;
					},
					translate: function(text) {
						var msg = this.messages[this.lang];
						if(msg) 
						{
							var toks = text.split('.');
							var tmp = msg;
							for(i=0; tmp!=null && i<toks.length; i++) 
							{
								tmp = tmp[toks[i]];
							}
							//console.log("text: "+text+" "+tmp);
							return tmp;
						}
						else 
						{
							return null;
						}
					},
					$t: function(text) 
					{
						return this.translate(text);
					},
					getLanguage: function() 
					{
						return this.lang=='de'? 0: 1;
					},
					createErrorMessage: function(text, data) 
					{
						var txt = data!=null? data: "No further info";
						var msg = {type: "error", text: text+txt};
						riot.store.trigger('message', msg);
					},
					createInfoMessage: function(text) 
					{
						var msg = {type: "info", text: text};
						riot.store.trigger('message', msg);
					},
					clearMessage: function() 
					{
						riot.store.trigger('message', null);
					}
				};
				riot.mixin(langmixin);
				
				var loader = 
				{
				    getHead: function()
				    {
				    	return document.getElementsByTagName("head")[0];
				    },
				    withNoCache: function(filename)
				    {
			            if(filename.indexOf("?") === -1)
			            {
			                filename += "?no_cache=" + new Date().getTime();
			            }
			            else
			            {
			                filename += "&no_cache=" + new Date().getTime();
			            }
			            return filename;
			        },
				    loadStyle: function(i, files, callback)
			        {
			        	if(i>=files.length)
			        	{
			        		callback();
			        	}
			        	else
			        	{
			        		var self = this;
			        		var link = document.createElement("link");
				            link.rel = "stylesheet";
				            link.type = "text/css";
				            link.href = self.withNoCache(files[i]);
				            
				            link.onload = function ()
				            {
				            	console.log('Loaded style: ' + files[i]);
				            	self.loadStyle(i+1, files, callback);
				            };
				            link.onerror = function ()
				            {
				                console.log('Error loading style: ' + files[i]);
				                self.loadStyle(i+1, files, callback);
				            };
				            
				            console.log('Loading style ' + files[i]);
				           	self.getHead().appendChild(link);
			        	}
			        },
			        loadScript: function(i, files, callback)
			        {
			        	if(i>=files.length)
			        	{
			        		callback();
			        	}
			        	else
			        	{
			        		var self = this;
				            var script = document.createElement('script');
				            script.type = 'text/javascript';
				            script.src = self.withNoCache(files[i]);
				            
				            script.onload = function ()
				            {
				                console.log('Loaded script: ' + files[i]);
				                self.loadScript(i+1, files, callback);
				            };
				            script.onerror = function ()
				            {
				                console.log('Error loading script: ' + files[i]);
				                self.loadScript(i+1, files, callback);
				            };
				            
				            console.log('Loading script ' + files[i]);
				            self.getHead().appendChild(script);
			        	}
			        },
			        loadFiles: function(files, callback)
			        {
			        	var self = this;
			        	
			        	 // this.m_head = document.head; // IE9+ only
				        var endsWith = function(str, suffix)
				        {
				            if(str === null || suffix === null)
				                return false;
				            return str.indexOf(suffix, str.length - suffix.length) !== -1;
				        }
			        	
			        	var jsfiles = [];
				        var cssfiles = [];
				        
			        	for(var i = 0; i < files.length; ++i)
				        {
				        	if(endsWith(files[i], ".css"))
				            {
				                cssfiles.push(files[i]);
				            }
				            else if(endsWith(files[i], ".js"))
				            {
				                jsfiles.push(files[i]);
				            }
				            else
				            {
				                self.log('Error unknown filetype "' + files[i] + '".');
				            }
				        }
			        	
			        	// loads recursively
			            self.loadStyle(0, cssfiles, function()
			            {
			            	self.loadScript(0, jsfiles, callback);
			            });
			        },
			       
				};
				riot.mixin(loader);
				
		    	riot.mount('*');
		    	
		    	var curpage = null;
		    	var target = "div#content";
		    	var routes = ["platforms", "platform", "about", "imprint", "privacy"];
		    	riot.store.language = "en";
		    	
		    	// As subpaths are supplied by separate args, internally arguments are used
		    	route(function changePath(path) 
		    	{
		    		path = path.toLowerCase();
		    		var paths = [];
		    		var params = null;
		    		for(i=0; i<arguments.length; i++)
		    		{
		    			if(arguments[i].indexOf("=")!=-1)
		    				params = arguments[i];
		    			else
		    				paths.push(arguments[i]);
		    		}
		    		//console.log(path);
		    		if(path.length==0)
		    			path="platforms";
		    		if(routes.includes(path)) 
		    		{ 
		    			if(curpage)
							curpage.unmount(true);
		    	        var tags = riot.mount(target, path, {paths: paths, params: params});
		    	        curpage = tags[0];
		    	        //console.log(tags);
		    		}
		    	});
		    	
		    	route.start(true);
		    	
		    	riot.store.switchLanguage();
			});
		</script>
	</body>
</html>
