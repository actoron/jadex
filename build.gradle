import java.awt.SplashScreen
import java.nio.file.Paths
import java.util.concurrent.Callable
import java.util.regex.Matcher
import org.gradle.api.artifacts.ProjectDependency
import org.apache.tools.ant.filters.*

apply plugin: 'java-library' // needed for distsDir on root project level

def maindistsuffix = ''
gradle.ext.selecteddists.each { dname ->
	maindistsuffix += '-' + dname
}
// resource files that are filtered for variables
project.ext.filterfiles = '*.xml,*.xsd,*.bat,*.sh,*.txt,*.gradle,*.md'

// resource files that are executable and should be flagged as such in the zip, must be subset of filterfiles
project.ext.execfiles = '*.bat,*.sh'

project.ext.srcdir = 'src'

project.ext.subprojectmap  = new HashMap()
project.subprojects.each { sp ->
	addSubproject(sp)
}

project.ext.keepplural = new HashSet<String>()
project.ext.keepplural.add('rules')
project.ext.keepplural.add('tools')
project.ext.keepplural.add('applications')

def ENABLE_ECLIPSE_ANDROID_WORKAROUNDS = false

buildscript 
{
    repositories
    {
        mavenLocal()
        mavenCentral()
        jcenter()
		maven
		{
			url "https://maven.google.com"
		}
    }

    dependencies
    {
        classpath 'com.android.tools.build:gradle:' + android_gradlePluginVersion
		classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.8.0'
		classpath 'com.github.dcendents:android-maven-gradle-plugin:2.0'
		classpath "io.codearte.gradle.nexus:gradle-nexus-staging-plugin:0.11.0" // for nexus-oss auto-close
	}

    apply from: "$rootDir/src/main/buildutils/util.gradle"
}

//apply plugin: 'eclipse'
//eclipse.project.buildCommands.remove('org.eclipse.jdt.core.javabuilder');

// Generate new timestamp for snapshot build unless -Pnoforcedirty=true is given
def forcedirty	= !findProperty("noforcedirty")
println 'forcedirty: ' + forcedirty + ', ' +forcedirty.class
project.ext.versionInfo	= BuildVersionManager.fetchVersionInfo(project, "src/main/buildutils/jadexversion.properties", forcedirty)
println 'Fetched version info:\n' + versionInfo.propertiesString

allprojects
{
	version	= versionInfo.toString()
	def gsuffix = ""
	if (getProjectDepth(project) > 1)
	{
		gsuffix = path.substring(0, path.lastIndexOf(":")).replace(":",".").substring(1)
	}
    if(isCommercial(project))
    {
	    group = 'com.actoron.jadex' + gsuffix
	}
	else
	{
	    group = 'org.activecomponents.jadex' + gsuffix
	}

    repositories
    {
        mavenCentral()
        
        // public sonatype repository for jmonkey artifacts
		maven
		{
			name 'sonatype public'
			url 'https://oss.sonatype.org/content/groups/public/'
		}
    }
    
    buildscript 
	{
	    repositories
	    {
			mavenLocal()
	    	mavenCentral()
	        maven
			{
				url "http://nexus.actoron.com/content/repositories/oss-nightlies/"
			}
			maven
			{
				url "https://maven.google.com"
			}
	    }
	}
	
	if (JavaVersion.current().isJava8Compatible()) {
		tasks.withType(Javadoc) {
        	options.addStringOption('Xdoclint:none', '-quiet')
        }
	}

	// Make builds reproducible, cf. https://dzone.com/articles/reproducible-builds-in-java
	project.afterEvaluate {
		tasks.withType(AbstractArchiveTask) {
			preserveFileTimestamps = false
			reproducibleFileOrder = true
		}
	}
}


// Create version.properties with new timestamp (i.e. after clean)
task createVersionInfo(type: Copy) {
	
	into project.buildDir
	from('src/main/buildutils') {
		include 'jadexversion.properties'
		filter(ReplaceTokens, beginToken: '${', endToken: '}', tokens: [versionInfoProperties: versionInfo.propertiesString])
		//expand( [versionInfoProperties: versionInfo.propertiesString])
	}
	mustRunAfter clean
	outputs.upToDateWhen {
		if(new File(project.projectDir, "build/jadexversion.properties").exists()) {
			def newInfo	= BuildVersionManager.fetchVersionInfo(project, "build/jadexversion.properties", false)
			if(versionInfo.equalsIgnoreTimestamp(newInfo)) {
				project.ext.versionInfo	= newInfo	// Use timestamp from previous build if no changes otherwise
				return true
			}
		}
		return false
	}
}

subprojects
{
    def mainSrcDir  = 'src/main/java'
    def testSrcDir  = 'src/test/java'
    def junit       = 'junit:junit:4.11'

	apply plugin: 'eclipse' // hack to allow starting web projects in eclipse with correct dependencies
	apply plugin: 'eclipse-wtp' // hack to allow starting web projects in eclipse with correct dependencies
	
	if (getProjectDepth(project) > 1)
	{
		
		def toplevelname = project.path.substring(1);
		toplevelname = toplevelname.substring(0, toplevelname.indexOf(':'))
		toplevelname = singularize(toplevelname)
		/*if (toplevelname.endsWith('s') && !keepplural.contains(toplevelname))
			toplevelname = toplevelname.substring(0, toplevelname.length() - 1)*/
		eclipse.project.name = toplevelname + '-' + project.name
	}
	else if (getProjectDepth(project) == 1) // Hack! Should not be needed?
		eclipse.project.name = project.path.substring(1)
	
	//if (project.getPath().toString().startsWith(":kernels") && !project.getPath().toString().equals(":kernels"))
	//{
		//eclipse.project.name = 'kernel-' + project.name
	//}
	
    ext.libraries = [
            android_support: "com.android.support:support-v4:26.1.0",
            android_compat: "com.android.support:appcompat-v7:26.1.0",
			// this is only useful if android plugin is NOT used by a project (lib):
            android: 'com.google.android:android:4.1.1.4',
			android_test: "com.android.support.test:runner:1.0.2",
//            android_test: "com.google.android:android-test:2.2.1",
            protobuf: "com.google.protobuf:protobuf-java:2.4.1",
            junit: junit,
            robotium: 'com.jayway.android.robotium:robotium-solo:5.6.3',
            robolectric: 'org.robolectric:robolectric:3.6.1'
    ]

	configurations {
		// apiNoAndroidRuntime will exclude the artifact in Android APKs
		runtimeAndroid.extendsFrom runtimeElements
		apiNoAndroidRuntime {
			dependencies.all { dep ->
				configurations.runtimeAndroid.exclude group: dep.group, module: dep.name
			}
		}
		api.extendsFrom apiNoAndroidRuntime
	}



    if(isAndroidProject(project))
    {

		buildscript {
			dependencies {
//				classpath group: 'org.activecomponents.jadex', name: 'jadex-gradle-plugin',
//						version: "$project.version.major.$project.version.minor.+"
				classpath group: 'org.activecomponents.jadex', name: 'jadex-gradle-plugin',
						version: "4.0.22"
			}
		}

		repositories {
			mavenCentral()
			maven
			{
				url "https://maven.google.com"
			}
		}

		// Disable Android lint nonsense.
		tasks.whenTaskAdded {task ->
		    if(task.name.contains("lint")) {
		        task.enabled = false
		    }
		}

	 	if (isAndroidLibraryProject(project))
        {
            apply plugin: 'com.android.library'
        }
        else
        {
            apply plugin: 'com.android.application'
        }


        if (ENABLE_ECLIPSE_ANDROID_WORKAROUNDS) addEclipseWorkarounds(project)

		// strip "-debug" from .aar and .apks to include them in dist
		onVariantOutput(project, com.android.builder.core.BuilderConstants.RELEASE) {output ->
			def fileName = output.outputFileName
			output.outputFileName = new File(output.outputFile.parent, "$archivesBaseName-${project.version}${fileName.substring(fileName.lastIndexOf("."))}").getName()
		}

    	android {
            compileSdkVersion android_compileSdkVersion
            buildToolsVersion android_buildToolsVersion

            defaultConfig {
                minSdkVersion android_minSdkVersion
                targetSdkVersion android_targetSdkVersion
                versionCode 1
				versionName project.version
				multiDexEnabled true
            }

            sourceSets {
                main {
                    manifest.srcFile 'src/main/AndroidManifest.xml'
                    resources.srcDirs = [mainSrcDir]
                    aidl.srcDirs = [mainSrcDir]
                    res.srcDirs = ['src/main/res']
                }
            }

            buildTypes {
                release {
                    // runProguard true
                    // proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
                }
            }

            packagingOptions {
                exclude 'LICENSE.txt'
                exclude 'META-INF/license.txt'
                exclude 'META-INF/notice.txt'
            }

            lintOptions {
                abortOnError false
            }

			dexOptions {
				jumboMode = true
				javaMaxHeapSize "4g"
			}
        }

		android.variantFilter { variant ->
			def build = variant.buildType.name
			if(build.equals(com.android.builder.core.BuilderConstants.DEBUG)) {
				variant.setIgnore(true);
			}		
		}
		
//		if(project.parent!=null && project.parent.parent!=null && project.parent.parent.parent!=null)
//			println 'Deep android project: '+project

		// Android zips are not produced by gradle zip task -> no reproducibleFileOrder=true setting possible, grrr
		// cf. https://issuetracker.google.com/issues/67597902
		if(isAndroidLibraryProject(project)) {
			project.afterEvaluate {
				project.tasks.matching {
//					it.name.startsWith('transformResourcesWithMergeJavaRes')
					it.name.startsWith('transformClassesAndResourcesWithSyncLibJars')
				}.each {task -> task.doFirst {
					// Intercept jar input to rebuild jar beforehands LOL :(
					task.getInputs().getFiles().filter({it.getName().endsWith(".jar")}).getFiles().each {file ->
						def rebuilddir	= new File(file.getParentFile(), "rebuild")
						rebuilddir.mkdirs()
						ant.unzip(src: file, dest: rebuilddir)
						project.tasks.create([name: "rebuildJar", type: Zip]) {
							destinationDir file.getParentFile()
							archiveName file.getName()
							from(rebuilddir) {
								includes = ['*/**']
							}
						}.execute()
//						println 'Rebuilt generated jar ' + file.getCanonicalPath() + ' ' + file.exists()
					}
				}}
			}
		}

        // include all resources that are placed inside src dirs
//        android.sourceSets.main.resources.srcDirs mainSrcDir
//        android.sourceSets.test.resources.srcDirs testSrcDir

		repositories {
			maven
			{
				url "https://maven.google.com"
			}
			jcenter()
		}
        dependencies
        {
            testImplementation junit
        }

		configurations {
			all {
				dependencies.all {
					dep -> excludeNonAndroidRuntimeFromApk(project, dep)
				}
			}
		}


    }
    else
    {
		apply plugin: 'java-library'
		if (isWebApplicationProject(project)) {
			apply plugin: 'war'
			artifacts {
				archives jar
			}
			war.baseName = getArtifactName(project)
		}
		jar.baseName = getArtifactName(project)
//			test {
//				reports.html.enabled = false
//			}
//		}
		test {
			testLogging {
				 showStandardStreams = true
			}
		}

        compileJava.options.encoding = 'UTF-8'
        // include all resources that are placed inside src dirs
        sourceSets.main.resources.srcDirs    mainSrcDir
        //sourceSets.main.output.resourcesDir = sourceSets.main.output.classesDir
        sourceSets.test.resources.srcDirs    testSrcDir
        //sourceSets.test.output.resourcesDir = sourceSets.test.output.classesDir

        dependencies
        {
            testImplementation junit
        }

		if(!sourceSets.main.resources.filter({file->file.name.equals('version.properties')}).isEmpty()) {
//			println 'processResources: ' + project + '\n' + versionInfo.propertiesString
	        processResources {
				filesMatching('**/version.properties')
				{
					filter(ReplaceTokens, beginToken: '${', endToken: '}', tokens: [versionInfoProperties: versionInfo.propertiesString])	//version props evaluated lazily!
					//expand( [versionInfoProperties: versionInfo.propertiesString])
				}
				inputs.files rootProject.createVersionInfo.outputs.files	// re-process when jadexversion.properties has changes
			}
		}

        afterEvaluate {
        	// Set correct bootclasspath for each project, depending on sourceCompatibility
            setBootClassPath(project)
			// add scope mappings to include parent configurations in deployed pom.xml
//			[install, uploadArchives].each { task ->
//				addParentScopeMappings(task, configurations.compile)
//			}
        }

//		test {
//			reports {
//				junitXml.enabled = true
//				html.enabled = true
//			}
//		}

    }
	addJavaDocJarTask(project)
	addSourcesJarTask(project)

	// needs to be applied after android + java plugins:
	if(project.getChildProjects().isEmpty()) {
//		println 'publishing leaf project ' + project
		apply from: "$rootDir/src/main/buildutils/publishing.gradle"
	}
//	else {
//		println 'not publishing grouping project ' + project
//	}

	
	// process schemas and generate schemadocs
	if (project.projectDir.toPath().resolve('src/main/schema').toFile().exists()) {
		addSchemaTasks(project)
	}

    sourceCompatibility = 1.8
    
    if(isTestParallel(project)) {
		tasks.withType(Test) {
 			maxParallelForks = Runtime.runtime.availableProcessors()
 		}
	}

    /* subprojects
    {
		task allDeps(type: DependencyReportTask) {}
	}*/
	
	// Add srcZip<Dist> tasks for project, if it is a dist project
	def	distname	=
		project.parent!=null && project.parent.name.equals("distributions")
			? project.name :
		project.parent!=null && project.parent.name.equals("addons")
			? 'addon'+project.name : null
	if(distname!=null) {
//		println 'dist: ' + distname + ', ' +isAddon([distname])
		def arts = gradle.ext.distartmap.get(distname)
		def prefixsize	= rootProject.projectDir.canonicalPath.length()
		def	isaddon	= isAddon([distname])

		task srcZip(type: Zip, dependsOn: rootProject.createVersionInfo) {
			destinationDir new File(rootProject.distsDir, "sources")
			archiveName 'jadex-'  + distname + '-' + project.version + '-sources.zip'
			
			// Add all included artifact projects and their parents (but exclude root project for addons)
			def projs = new HashSet();	// keep track of added projects to avoid duplicates
			arts.each { artname ->
				Project sp = subprojectmap.get(artname)
				while((isaddon?sp!=rootProject:sp!=null) && !projs.contains(sp)) {
					projs.add(sp);
					from(sp.projectDir) {
						into 'sources' + sp.projectDir.canonicalPath.replace(File.separator, "/").substring(prefixsize)
						includes = ['*.properties', '*.gradle', 'src/**', 'dist/**', 'lib/**', 'gradle/**', 'gradlew.bat']
						excludes = ['secret.properties', '**/.gradle', 'src/main/config', 'src/main/buildutils/jadexversion.properties']
					}
					from(sp.projectDir) {
						into 'sources' + sp.projectDir.canonicalPath.replace(File.separator, "/").substring(prefixsize)
						include	'gradlew'
						fileMode 0755
					}
//					// Allow special files being included in source tree (e.g. readmes for building)
//					from(new File(sp.projectDir, '/dist/sources')) {
//						into 'sources'
//						includes = ['*/**']
//					}
					sp	= sp.parent;
				}
			}
			if(!isaddon) {
				// Add preprocessed version properties
				from(rootProject.buildDir.getCanonicalPath()) {
					into 'sources/src/main/buildutils'
					includes = ['jadexversion.properties']
				}
				
				// Add build helper project
				def helpdir	= new File(rootProject.projectDir, "buildSrc")
				from(helpdir) {
					into 'sources' + helpdir.canonicalPath.replace(File.separator, "/").substring(prefixsize)
					includes = ['*.properties', '*.gradle', 'src/**', 'dist/**', 'lib/**', 'gradle/**', 'gradlew.bat']
					excludes = ['secret.properties', '**/.gradle', 'src/main/config', 'src/main/buildutils/jadexversion.properties']
				}
			}			
		}

		// Create examplesZip task(s), if any
		def dir	= new File(project.projectDir, 'dist/exampleprojects')
		if(dir.exists() && dir.isDirectory())
		{
			def examples	= dir.listFiles().findAll { it.isDirectory() }
			examples.each { example ->
				def task	= project.tasks.create([name: examples.size()==1 ? "exampleZip" : "exampleZip-" + example.getName(), type: Zip]) {
					destinationDir new File(rootProject.distsDir, 'exampleprojects')
					archiveName example.getName() + '.zip'
					from (example) {
						into example.getName()
						include '**/*'
						exclude rootProject.ext.filterfiles.split("\\s*,\\s*")
					}
					from (example) {
						into example.getName()
						include rootProject.ext.filterfiles.split("\\s*,\\s*")
						filter(ReplaceTokens, beginToken: '${', endToken: '}', tokens: [jadex_build_version: project.version])
						//expand( [jadex_build_version: project.version])
					}
				}
			}
		}

		// Create distZip task
		task distZip(type: Zip) {
			def commercial = false
			archiveName 'jadex-'  + distname  + '-' + project.version + '.zip'
			gradle.projectsEvaluated() {
				// Add all included artifact projects and their parents (but exclude root project for addons)
				def projs = new HashSet();	// keep track of added projects to avoid duplicates
				def projs_orig = new HashSet();	// compare hierarchy vs arts only
				def extdists = new HashSet()	// keep track of added extra artifacts to avoid duplicates
				arts.each { artname ->
					Project sp = subprojectmap.get(artname)
					projs_orig.add(sp)
//					println 'artifact: ' +sp
					commercial |= isCommercial(sp)
					while((isaddon?sp!=rootProject:sp!=null) && !projs.contains(sp)) {
						projs.add(sp);

						if (isAndroidProject(sp)) {
							// apps as debug version, because unsigned releases do not run on android
							def assembletask	= sp.tasks.find {isAndroidLibraryProject(sp) ? it.name.equals('bundleReleaseAar') : it.name.equals('packageRelease')} // apk debug???
							if(assembletask!=null) {
								from(assembletask.outputs) {
									into 'jadex-'  + project.version + (isAndroidLibraryProject(sp) ? '/lib' : '/apps')
									exclude '/tmp/**', '/release/**', 'output.json'
								}
							}
							else {
								println 'No output task found for project: ' + sp
//								sp.tasks.each { task ->
//									println 'Task ' + task + ': ' + task.outputs.files.files
//								}
							}
						}
						// Only collect artifacts from leaf projects
						else if(sp.getChildProjects().isEmpty()) {
							if (isApp(sp)) {
								// Legacy mode: include war and jar in apps!?
								def mytasks	= sp.tasks.matching {
									it.name.equals('war') || it.name.equals('jar')
								}
								// Fetch jar only if no war.
//								if(mytasks.isEmpty())
//									mytasks	= sp.tasks.matching {it.name.equals('jar')}
								mytasks.each {task ->
									from(task.outputs) {
										into 'jadex-'  + project.version + '/apps'
									}
								}
							}
							else  {
								// Fetch jar if any.
								sp.tasks.matching {
									it.name.equals('jar')
								}.each {task ->
//									println 'outputs: ' + task + ', ' + task.outputs.files.files
									//&& !sp.getPath().contains(':distributions:')	// Legacy(?) hack: do not include distribution projects, todo: include? or exclude all dist/no-content projects
									from(task.outputs) {
										into 'jadex-'  + project.version + '/lib'
									}
								}
		
								// copy all runtime deps:
								if(sp.parent!=null) {
									// 'runtimeElements' instead of 'runtime'!? cf. https://docs.gradle.org/current/userguide/java_library_plugin.html#sec:java_library_configurations_graph
									def runtimeConfig = distname.contains('android') ? sp.configurations.runtimeAndroid :sp.configurations.runtimeElements
									def detached = getDetachedConfiguration(sp, runtimeConfig)
									detached.each { file ->
										if (!extdists.contains(file)) {
											from (file.getParent()) {
												into 'jadex-'  + project.version + '/lib'
												includes = [file.getName()]
											}
											extdists.add(file)
										}
									}
								}
							}
						}
	
						// Files to be included from dist/files directories
						// 1) plain files w/o filtering or executable flag
						from(new File(sp.projectDir, '/dist/files')) {
							into 'jadex-'  + project.version
							include	'*/**'
							exclude rootProject.ext.filterfiles.split("\\s*,\\s*")
							exclude rootProject.ext.execfiles.split("\\s*,\\s*")
						}
						// 2) files with filtering but not executable
						from(new File(sp.projectDir, '/dist/files')) {
							into 'jadex-'  + project.version
							include	rootProject.ext.filterfiles.split("\\s*,\\s*")
							exclude	rootProject.ext.execfiles.split("\\s*,\\s*")
							filter(ReplaceTokens, beginToken: '${', endToken: '}', tokens: [jadex_build_version: project.version])
							//expand( [jadex_build_version: project.version])
						}
						// 3) executable files with new permissions (always filtered)
						from(new File(sp.projectDir, '/dist/files')) {
							into 'jadex-'  + project.version
							include	rootProject.ext.execfiles.split("\\s*,\\s*")
							filter(ReplaceTokens, beginToken: '${', endToken: '}', tokens: [jadex_build_version: project.version])
							//expand( [jadex_build_version: project.version])
							fileMode 0755	// Does not work with 755!?
						}
						
						// Copy generated example zips, if any
						sp.tasks.matching {
							it.name.startsWith('exampleZip')
						}.each { task ->
							from(task.outputs) {
								into 'jadex-'  + project.version
							}
						}
	
						sp	= sp.parent;
					}
				}
			
				println 'Distribution "' + distname + '" is ' + (commercial? 'commercial' : 'non-commercial') + ' and ' + (isaddon? 'an add-on.' : 'standalone.')
				destinationDir new File(rootProject.distsDir, commercial? 'commercial' : 'noncommercial')
			}
			
			// Copy generated srcZip
			from(project.srcZip.outputs) {
				into 'jadex-'  + project.version
				rename {name -> isaddon ? 'sources-' + distname + '.zip' : 'sources.zip'}
			}
		}
		
		// TODO: checkDist for addons too.
		if(!isaddon) {
			task checkDist()  {
				description	= "Rebuild the distribution from source.zip and check if newly generated dist.zip matches original."
				dependsOn distZip
				
				doLast {
					checkDistZip(distname, arts, isaddon)
				}
			}
		}
	}
}

task copyJavaDocSources(type: Copy) {
	destinationDir = new File(project.distsDir.getCanonicalPath() + '/javadocworkdir')
	gradle.ext.maindistartifacts.each { artname ->
		def sp = project.ext.subprojectmap.get(artname)
		if (sp == null)
			println 'SUBPROJECT NOT FOUND:' + ' ' + artname
		from(sp.projectDir.getCanonicalPath() + '/src/main/java') {
			include '**/*.java'
			exclude '**/org/apache/**'
			exclude '**/impl/**'
		}
	}
	def comment = false

	/* Filter to fix some HTML-entity/Javadoc nonsense */
	filter { line ->
		if (line.trim().startsWith('/**'))
			comment = true

		if (comment) {
			line = line.replaceAll('(?<!code)>','&gt;')
			if (line.contains('*/'))
				comment = false;
		}
		return line
	}
}



task javadocZip(type: Javadoc, dependsOn: [copyJavaDocSources]) {
	def sourcedir = project.distsDir.getCanonicalPath() + '/javadocworkdir'
	source(sourcedir)
	destinationDir = new File(project.distsDir.getCanonicalPath() + '/jadex-' + project.version + '-javadoc')

	options.encoding 'UTF-8'
	options.docEncoding 'UTF-8'
	options.charSet 'UTF-8'
	options.quiet()

	options.docTitle("Jadex Active Component Platform ${project.version} API")
	options.windowTitle("Jadex Active Component Platform ${project.version} API")
	options.group('Core Packages','jadex.commons*:jadex.bridge*')
	options.group('Micro Agent Packages','jadex.micro*')
	options.group('BPMN Process Packages','jadex.bpmn*')
	options.group('BDI Agent Packages','jadex.bdi*')
	options.group('Web Service Extension Packages','jadex.extension.ws*:jadex.extension.rs*')
	options.group('2D/3D Environment Extension Packages','')
	options.group('Agent-Group-Role (AGR) Extension Packages','jadex.extension.agr*')

	doLast {
		def ant = new groovy.util.AntBuilder()
		ant.sequential {
			ant.delete dir: sourcedir
			ant.zip destfile: destinationDir.getCanonicalPath() + '.zip', {
				zipfileset dir: destinationDir.getCanonicalPath(), prefix: 'javadoc' + '/', erroronmissingdir: false
			}
			ant.delete dir: destinationDir
		}
	}
	outputs.upToDateWhen {false}
}

//task exampleZips {
//	String outputdir = project.distsDir.getCanonicalPath() + '/exampleprojects/'
//	outputs.dir outputdir
//	doLast {
//		def preprocessdirfile = new File(project.distsDir.getCanonicalPath() + '/tmp')
//		def preprocessdir = preprocessdirfile.getCanonicalPath()
//		//String outputdir = project.distsDir.getCanonicalPath() + '/exampleprojects/'
//		String buildExcludes = 'build/**, classes/**, target/**, bin/**, .gradle/**, .idea/**, *.iml'
//		gradle.ext.maindistartifacts.parallelStream().forEach { artname ->
//			Project sp = project.ext.subprojectmap.get(artname)
//			File exdir = new File(sp.projectDir.getCanonicalPath() + '/dist/exampleprojects')
//			if (exdir.exists() && exdir.isDirectory()) {
//				exdir.listFiles().each { ex ->
//					preprocessdirfile.mkdirs()
//					def ant = new groovy.util.AntBuilder()
//					ant.sequential {
//						ant.copy todir: preprocessdir + '/' + ex.getName(),
//						{
//							resources
//							{
//								fileset dir: ex.getCanonicalPath(), includes: project.ext.filterfiles, erroronmissingdir: false
//							}
//
//							filterset begintoken: '${', endtoken: '}',
//							{
//								filter token: 'jadex_build_version', value: project.version
//							}
//						}
//						ant.copy todir: preprocessdir + '/' + ex.getName(),
//						{
//							resources
//							{
//								fileset dir: ex.getCanonicalPath(), excludes: project.ext.filterfiles + ', ' + buildExcludes, erroronmissingdir: false
//							}
//						}
////						ant.zip(destfile: outputdir + ex.getName() + '.zip', basedir: preprocessdir, includes: ex.getName() + '/**')
//						//ant.delete dir: preprocessdir
//					}
//					def zipExample = project.tasks.create([name: "zipExample"+ex.getName(), type: Zip])
//					zipExample.destinationDir = file(outputdir)
//					zipExample.archiveName = ex.getName() + '.zip'
//					zipExample.from(preprocessdir)
//					zipExample.include(ex.getName() + '/**')
//					zipExample.execute()
//				}
//			}
//		}
//	}
//}
//
//// Legacy for testing if new mode produces same output
//task srcZips(dependsOn: createVersionInfo) {
//	doLast {
//		gradle.ext.selecteddists.parallelStream().forEach { selecteddist ->
//			def arts = gradle.ext.distartmap.get(selecteddist)
//			createSrcZip(selecteddist, arts, selecteddist.startsWith('addon'))
//		}
//	}
//	dependsOn subprojects.collect({p -> p.tasks.matching{it.name.equals('srcZip')}}).flatten()
//}
//
//task distZips(dependsOn: [subprojects.build, srcZips, exampleZips])  {
//	description	= "Build separate zips for all selected distributions. Use '-P dist=<distnames>' to specify distributions (default 'everything'). Available distibutions can be found in the first row of src/main/buildutils/buildconfigs.csv."
//
//	doLast {
//		gradle.ext.selecteddists.parallelStream().forEach {selecteddist ->
//			def arts = gradle.ext.distartmap.get(selecteddist)
//			createDistZip(selecteddist, arts, selecteddist.startsWith('addon'))
//		}
//	}
//	dependsOn subprojects.collect({p -> p.tasks.matching{it.name.equals('distZip')}}).flatten()
//}

// for shared stable/master jenkinsfile in buildscripts
task distZips()  {
	description	= "Build separate zips for all selected distributions. Use '-P dist=<distnames>' to specify distributions (default 'everything'). Available distibutions can be found in the first row of src/main/buildutils/buildconfigs.csv."
	dependsOn subprojects.collect({p -> p.tasks.matching{it.name.equals('distZip')}}).flatten()
}


task checkDists()  {
	description	= "Build separate zips for all selected distributions. Use '-P dist=<distnames>' to specify distributions (default 'everything'). Available distibutions can be found in the first row of src/main/buildutils/buildconfigs.csv."

	doLast {
		gradle.ext.selecteddists.parallelStream().forEach {selecteddist ->
			if(!selecteddist.startsWith('addon'))	// Exclude addons for now. TODO: fix addon dists!
			{
				def arts = gradle.ext.distartmap.get(selecteddist)
				checkDistZip(selecteddist, arts, selecteddist.startsWith('addon'))
			}
		}
	}
	dependsOn subprojects.collect({p -> p.tasks.matching{it.name.equals('distZip')}}).flatten()
}

def checkDistZip(distname, arts, isaddon)
{
	def commercial = false
	arts.each { artname ->
		commercial |= isCommercial(project.ext.subprojectmap.get(artname))
	}
	def rebuilddirfile = new File(project.distsDir, 'rebuild/'+distname);
	rebuilddirfile.mkdirs()
	def srczip	= new File(project.distsDir, 'sources/jadex-' + distname  + '-' + project.version + '-sources.zip')

	// For debugging srcZip
	def srczip2	= new File(rebuilddirfile, 'sources/build/distributions/sources/jadex-'  + distname  + '-' + project.version + '-sources.zip')
	def srcdiff	= diffZips(srczip.getCanonicalPath(), srczip2.getCanonicalPath())
	if(srcdiff.length()!=0)
		throw new RuntimeException("Rebuilt srcZip does not match original: "+srcdiff);
	
	// Extract and build sources.zip
	ant.unzip(src: srczip, dest: rebuilddirfile)
//	// Hack!!! extract minimal zip also, as addons do not build on their own 
//	if(isaddon)
//		ant.unzip(src: new File(project.distsDir, 'tmp/minimal/sources.zip'), dest: rebuilddirfile)
	// https://stackoverflow.com/questions/26459067/how-to-run-gradle-script-from-gradle
	def artefactBuild = project.tasks.create([name: "checkDist"+distname.substring(0,1).toUpperCase()+distname.substring(1), type: GradleBuild])
	artefactBuild.buildFile = project.file(new File(rebuilddirfile, "sources/build.gradle"))
	artefactBuild.tasks = ["distZip"]
	artefactBuild.startParameter.excludedTaskNames	= ["test", "javadoc"]
	artefactBuild.startParameter.projectProperties << [dist: distname, noforcedirty: true]
	artefactBuild.execute()
	
//	// For debugging bluetooth aar
//	if(subprojectmap.get(":android:bluetooth")!=null) {
//		def zip1	= new File(project.projectDir, 'android/bluetooth/build/intermediates/packaged-classes/release/classes.jar')
//		def zip2	= new File(rebuilddirfile, 'sources/android/bluetooth/build/intermediates/packaged-classes/release/classes.jar')
//		def diff	= diffZips(zip1, zip2)
//		if(diff.length()!=0)
//			throw new RuntimeException("Rebuilt bluetooth classes.jar does not match original: "+diff);		
//		zip1	= new File(project.projectDir, 'android/bluetooth/build/outputs/aar/bluetooth-' + project.version + '.aar')
//		zip2	= new File(rebuilddirfile, 'sources/android/bluetooth/build/outputs/aar/bluetooth-' + project.version + '.aar')
//		diff	= diffZips(zip1, zip2)
//		if(diff.length()!=0)
//			throw new RuntimeException("Rebuilt bluetooth-" + project.version + ".aar does not match original: "+diff);		
//	}
	
	// Check original and rebuilt dist for equality based on zip contents (<name> only as <size> and <crc> depends on random file order on disk when building zip)
	def distzip = project.distsDir.getCanonicalPath() + (commercial? '/commercial' : '/noncommercial') + '/' + 'jadex-'  + distname  + '-' + project.version + '.zip'
	def distzip2 = rebuilddirfile.getCanonicalPath() + '/sources/build/distributions' + (commercial? '/commercial' : '/noncommercial') + '/' + 'jadex-'  + distname  + '-' + project.version + '.zip'
	def diff	= diffZips(distzip, distzip2)
	if(diff.length()!=0)
		throw new RuntimeException("Rebuilt jadex-" + distname + "-" + project.version + ".zip does not match original: "+diff);		
}

//def createDistZip(distname, arts, isaddon)
//{
//	def commercial = false
//	arts.each { artname ->
//		commercial |= isCommercial(project.ext.subprojectmap.get(artname))
//	}
//	println 'Distribution "' + distname + '" is ' + (commercial? 'commercial' : 'non-commercial') + ' and ' + (isaddon? 'an add-on.' : 'standalone.')
//
//	def preprocessdirfile = new File(project.distsDir, 'tmp/'+distname)
//	preprocessdirfile.mkdirs()
//	def preprocessdir = preprocessdirfile.getCanonicalPath()
//	def foldername = 'jadex-'  + project.version
//	def zipfilename = project.distsDir.getCanonicalPath() + (commercial? '/commercial' : '/noncommercial') + '/' + 'jadex-'  + distname  + '-' + project.version + 'Old.zip'
//	def distdir = project.distsDir.getCanonicalPath()
//	def ant = new groovy.util.AntBuilder()
//	def extdists = new HashSet()
//
//	ant.sequential {
//		ant.copy todir: preprocessdir,
//		{
//			resources
//			{
//				arts.each { artname ->
//					def sp = project.ext.subprojectmap.get(artname)
//					fileset dir: sp.projectDir.getCanonicalPath() + '/dist/files', includes: project.ext.filterfiles, erroronmissingdir: false
//				}
//			}
//
//			filterset begintoken: '${', endtoken: '}',
//			{
//				filter token: 'jadex_build_version', value: project.version
//			}
//		}
//		if (isaddon)
//		{
//			ant.copy file: project.distsDir.getCanonicalPath() + '/sources/jadex-'  + distname  + '-' + project.version + '-sources.zip', tofile: preprocessdir + '/sources-' + distname + '.zip'
//		}
//		else
//		{
//			ant.copy file: project.distsDir.getCanonicalPath() + '/sources/jadex-'  + distname  + '-' + project.version + '-sources.zip', tofile: preprocessdir + '/sources.zip'
//		}
//		ant.zip destfile: zipfilename,
//		{
//			arts.each { artname ->
//				def sp = project.ext.subprojectmap.get(artname)
//				println 'ant artifact: ' +sp
//				def spbdir = sp.buildDir.getCanonicalPath()
//
//				if (isAndroidProject(sp)) {
//
//					def targetFolder = '/apps/'
//					if (isAndroidLibraryProject(sp)) {
//						targetFolder = '/lib/'
//						onVariantOutput(sp, com.android.builder.core.BuilderConstants.RELEASE) {output ->
//							zipfileset dir: output.outputFile.getParent(), prefix: foldername + targetFolder, includes:  output.outputFile.getName(), erroronmissingdir: true
//						}
//					} else {
//						// apps as debug version, because unsigned releases to not run on android
//						onVariantOutput(sp, com.android.builder.core.BuilderConstants.DEBUG) {output ->
//							zipfileset dir: output.outputFile.getParent(), prefix: foldername + targetFolder, includes:  output.outputFile.getName(), erroronmissingdir: true
//						}
//					}
//
//				} else {
//					if (isApp(sp)) {
//						zipfileset dir: spbdir + '/libs', prefix: foldername + '/apps/', includes: '*.jar,*.war', excludes: '*-sources.jar,*-javadoc.jar,jadex-distribution-*.jar,*-test.jar', erroronmissingdir: false
//					}
//					else {
//						zipfileset dir: spbdir + '/libs', prefix: foldername + '/lib/', includes: '*.jar', excludes: '*-sources.jar,*-javadoc.jar,jadex-distribution-*.jar,*-test.jar', erroronmissingdir: false
//
//						// copy all runtime deps:
//						def runtimeConfig = sp.configurations.runtimeElements	// 'runtimeElements' instead of 'runtime'!? cf. https://docs.gradle.org/current/userguide/java_library_plugin.html#sec:java_library_configurations_graph
//						if (distname.contains('android')) {
//							runtimeConfig = sp.configurations.runtimeAndroid
//						}
//
//						def detached = getDetachedConfiguration(sp, runtimeConfig)
//						detached.each { file ->
//							if (!extdists.contains(file)) {
//								zipfileset file: file, prefix: foldername + '/lib/'
//								extdists.add(file)
//							}
//						}
//					}
//				}
//
//				zipfileset dir: sp.projectDir.getCanonicalPath() + '/dist/files', prefix: foldername + '/', excludes: project.ext.filterfiles, erroronmissingdir: false
//
//				def exdir = new File(sp.projectDir.getCanonicalPath() + File.separator + 'dist/exampleprojects')
//				if (exdir.exists() && exdir.isDirectory()) {
//					exdir.listFiles().each { ex ->
//						zipfileset dir: project.distsDir.getCanonicalPath() + '/exampleprojects/', prefix: foldername + '/', includes: ex.getName() + '.zip'
//					}
//				}
//			}
//
//			zipfileset dir: preprocessdir, prefix: foldername + '/', excludes: project.ext.execfiles, erroronmissingdir: false
//			zipfileset dir: preprocessdir, prefix: foldername + '/', includes: project.ext.execfiles, filemode: 755, erroronmissingdir: false
//		}
//		//ant.delete dir: preprocessdir
//	}
//	
//	// Check original and rebuilt dist for equality based on zip contents (<name> only as <size> and <crc> depends on random file order on disk when building zip)
//	def distzip11 = project.distsDir.getCanonicalPath() + (commercial? '/commercial' : '/noncommercial') + '/' + 'jadex-'  + distname  + '-' + project.version + 'Old.zip'
//	def distzip22 = project.distsDir.getCanonicalPath() + (commercial? '/commercial' : '/noncommercial') + '/' + 'jadex-'  + distname  + '-' + project.version + '.zip'
//	def difff	= diffZips(distzip11, distzip22)
//	if(difff.length()!=0)
//		throw new RuntimeException("Gradle based jadex-" + distname + "-" + project.version + ".zip does not match old ant based: "+difff);
//}
//
//
//def createSrcZip(distname, arts, isaddon)
//{
//	//-------- old ant zip for reference --------
//	def mainzipdir = 'sources/'
//	String maindir = project.projectDir.getCanonicalPath()
//	String zipfilename = project.distsDir.getCanonicalPath() + '/sources/jadex-'  + distname + '-' + project.version + '-sourcesOld.zip'
//	def ant = new groovy.util.AntBuilder()
//	ant.sequential {
//		zip destfile: zipfilename,
//		{
//			Set<String> done = new HashSet();
//			arts.each { artname ->
//				Project sp = subprojectmap.get(artname)
//				while(sp!=rootProject && !done.contains(sp)) {
//					// each project: sources + resources
//					String prefix = (mainzipdir + Paths.get(maindir).relativize(sp.projectDir.toPath()).toString()).replace(File.separator, "/") // handle nested paths correctly
//					zipfileset dir: sp.projectDir.getCanonicalPath() + '/' + srcdir, prefix: prefix +'/' + srcdir,  erroronmissingdir: false
//					// each project: dist directory
//					zipfileset dir: sp.projectDir.getCanonicalPath() + '/dist', prefix: prefix + '/dist',  erroronmissingdir: false, excludes: '**/build/**'
//					// each project: build script files
//					zipfileset dir: sp.projectDir.getCanonicalPath(), prefix: prefix, includes: '*.gradle, *.properties, lib/**',  erroronmissingdir: false
//					
//					done.add(sp)
//					sp=sp.parent
//				}
//			}
//
////			for (String topdir : toplevels)
////			{
////				String prefix = (mainzipdir + Paths.get(maindir).relativize(Paths.get(topdir)).toString()).replace(File.separator, "/")
////				zipfileset dir: topdir, prefix: prefix, includes: '*.gradle, *.properties, lib/**',  erroronmissingdir: false
////			}
//
//			// top-level build script files
//			if (!isaddon) {
//				zipfileset dir: maindir, prefix: mainzipdir, includes: '*.gradle, gradle.properties, gradle/wrapper/*', excludes: '.gradle'
//				zipfileset dir: maindir, prefix: mainzipdir, includes: 'gradlew, gradlew.bat', filemode: 755
//				zipfileset dir: maindir, prefix: mainzipdir, includes: 'src/main/buildutils/**/*', excludes: 'src/main/buildutils/jadexversion.properties'
//				zipfileset dir: maindir, prefix: mainzipdir, includes: 'dependencies.conf'
//				zipfileset dir: project.buildDir.getCanonicalPath(), prefix: mainzipdir + 'src/main/buildutils/', includes: 'jadexversion.properties'
//			}
//		}
//	}
//
//	// Check original and rebuilt dist for equality based on zip contents (<name> only as <size> and <crc> depends on random file order on disk when building zip)
//	def zip1 = project.distsDir.getCanonicalPath() + '/sources/jadex-'  + distname + '-' + project.version + '-sourcesOld.zip'
//	def zip2 = project.distsDir.getCanonicalPath() + '/sources/jadex-'  + distname + '-' + project.version + '-sources.zip'
//	def diff	= diffZips(zip1, zip2)
//	if(diff.length()!=0)
//		throw new RuntimeException("New jadex-" + distname + "-" + project.version + "-sources.zip does not match original: "+diff);
//}

task performanceTest() {
	description="Execute performance tests. Be sure to call this with a dist that includes some performance tests, such as 'everything'."

	subprojects.findAll { it.getTasksByName('performanceTest', false) }.each {
		performanceTest.dependsOn += it.performanceTest
	}
}

/* Recursively add subprojects */
def addSubproject(proj)
{
	def pname = proj.getPath()
	project.ext.subprojectmap.put(pname, proj)
	proj.subprojects.each { sp ->
		addSubproject(sp)
	}
}

task copyJars(type: Copy) {
    from subprojects.collect { it.tasks.withType(AbstractArchiveTask) }
    exclude '**/*.jar', '**/*.aar'
    into "$buildDir/apps"
}

task testReport(type: TestReport) {
    destinationDir = file("testreport")
    // Include the results from the `test` task in all subprojects
    //reportOn subprojects*.test
	reportOn subprojects.collect { it.tasks.withType(Test).collect {it.binResultsDir} }
}

task checkReproducible(type: Exec) {
	def command	= 'mkdir -p /jadex/.reproduce/ && cd /jadex/.reproduce/' +
		' && if [ -d /jadex/.reproduce/jadex ]; then cd /jadex/.reproduce/jadex && git pull; else git clone --no-local /jadex/.git && cd /jadex/.reproduce/jadex; fi' +
		' && git checkout ' + versionInfo.branch
		' && git checkout ' + versionInfo.commit
	commandLine ('docker', 'run', '--rm', '--name', 'reproduce',
		'-v', project.projectDir.canonicalPath + ':/jadex',
		'--entrypoint', '/bin/sh', 'alpine/git', '-c', "\"$command\"")
}
